<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>

<link href="index_notoc_files/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="index_notoc_files/highlightjs-1.1/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>





</head>

<body>







<p>All code for this document is located at <a href="https://raw.githubusercontent.com/muschellij2/neuroc/master/fmri_analysis_ANTsR/index.R">here</a>.</p>
<p>In this tutorial we will discuss performing some preprocessing of a single subject functional MRI in FSL.</p>
<div id="data-packages" class="section level1">
<h1>Data Packages</h1>
<p>For this analysis, I will use one subject from the Kirby 21 data set. The <code>kirby21.base</code> and <code>kirby21.fmri</code> packages are necessary for this analysis and have the data we will be working on. You need devtools to install these. Please refer to <a href="neuroc-help-installing-devtools">installing devtools</a> for additional instructions or troubleshooting.</p>
<pre class="r"><code>packages = installed.packages()
packages = packages[, &quot;Package&quot;]
if (!&quot;kirby21.base&quot; %in% packages) {
  devtools::install_github(&quot;muschellij2/kirby21.base&quot;)
}
if (!&quot;kirby21.fmri&quot; %in% packages) {
  devtools::install_github(&quot;muschellij2/kirby21.fmri&quot;)
}</code></pre>
</div>
<div id="loading-data" class="section level1">
<h1>Loading Data</h1>
<p>We will use the <code>get_image_filenames_df</code> function to extract the filenames on our hard disk for the T1 image and the fMRI images (4D).</p>
<pre class="r"><code>library(kirby21.fmri)
library(kirby21.base)
fnames = get_image_filenames_df(ids = 113, 
                    modalities = c(&quot;T1&quot;, &quot;fMRI&quot;), 
                    visits = c(1),
                    long = FALSE)
t1_fname = fnames$T1[1]
fmri_fname = fnames$fMRI[1]</code></pre>
<div id="parameter-file" class="section level2">
<h2>Parameter file</h2>
<p>If you’d like to see the header information from the fMRI data, it is located by the following commands:</p>
<pre class="r"><code>library(R.utils)
par_file = system.file(&quot;visit_1/113/113-01-fMRI.par.gz&quot;, 
                       package = &quot;kirby21.fmri&quot;)
# unzip it
con = gunzip(par_file, temporary = TRUE, 
             remove = FALSE, overwrite = TRUE)
info = readLines(con = con)
info[11:23]</code></pre>
<pre><code> [1] &quot;.    Protocol name                      :   WIP Bold_Rest SENSE&quot;
 [2] &quot;.    Series Type                        :   Image   MRSERIES&quot;   
 [3] &quot;.    Acquisition nr                     :   11&quot;                 
 [4] &quot;.    Reconstruction nr                  :   1&quot;                  
 [5] &quot;.    Scan Duration [sec]                :   434&quot;                
 [6] &quot;.    Max. number of cardiac phases      :   1&quot;                  
 [7] &quot;.    Max. number of echoes              :   1&quot;                  
 [8] &quot;.    Max. number of slices/locations    :   37&quot;                 
 [9] &quot;.    Max. number of dynamics            :   210&quot;                
[10] &quot;.    Max. number of mixes               :   1&quot;                  
[11] &quot;.    Patient position                   :   Head First Supine&quot;  
[12] &quot;.    Preparation direction              :   Anterior-Posterior&quot; 
[13] &quot;.    Technique                          :   FEEPI&quot;              </code></pre>
<p>From the paper <a href="http://dx.doi.org/10.1016/j.neuroimage.2010.11.047">“Multi-parametric neuroimaging reproducibility: A 3-T resource study”</a>, which this data is based on, it describes the fMRI sequence:</p>
<blockquote>
<p>The sequence used for resting state functional connectivity MRI is typically identical to that used for BOLD functional MRI studies of task activation. Here, we used a 2D EPI sequence with SENSE partial-parallel imaging acceleration to obtain 3 × 3 mm (80 by 80 voxels) in-plane resolution in thirty-seven 3 mm transverse slices with 1 mm slice gap. An ascending slice order with TR/TE = 2000/30 ms, flip angle of 75°, and SENSE acceleration factor of 2 were used. SPIR was used for fat suppression. This study used an ascending slice acquisition order because a pilot studies revealed smaller motion induced artifacts with ascending slice order than with interleaved slice order. While using an ascending slice order, it was necessary to use a small slice gap to prevent cross talk between the slices. One 7-min run was recorded which provided 210 time points (discarding the first four volumes to achieve steady state).</p>
</blockquote>
</div>
</div>
<div id="outline" class="section level1">
<h1>Outline</h1>
<p>The steps I will perform in this analysis:</p>
<ol style="list-style-type: decimal">
<li>Calculation of Motion Parameters (<code>fslr::mcflirt</code>)</li>
<li>Slice timing correction (<code>fslr::fsl_slicetimer</code>), but we need to know how the scan was taken/slice order and repetition time (TR)</li>
<li>Motion Correction on Corrected Data (<code>fslr::mcflirt</code>)</li>
<li>Coregistration of fMRI and a T1-weighted image (<code>fslr::flirt</code>)</li>
<li>Registration to the Template space (<code>fslr::fnirt_with_affine</code> )</li>
<li>Skull stripping (fslr::fslbet)</li>
<li>Registration to a template using the T1 and then transforming the fMRI with it</li>
<li>Spatially smoothing the data (fslr:fslsmooth)</li>
<li>Tissue-class segmentation (fslr::fast, ANTsR::atropos or extrantsr::otropos)?</li>
<li>Bandpass/butterworth filtering (signal::butter, signal::buttord)</li>
<li>Get a connectivity matrix of certain regions, you need to specify an atlas.</li>
</ol>
<p>Now we know that the head is first in (as usual) and the data was acquired in ascending order (i.e. bottom -&gt; up) and the repetition time (TR) was 2 seconds The</p>
<pre class="r"><code>library(neurobase)
fmri = readnii(fmri_fname)
ortho2(fmri, w = 1, add.orient = FALSE)</code></pre>
<p><img src="index_files/figure-html/fmri-1.png" /><!-- --></p>
<pre class="r"><code>rm(list = &quot;fmri&quot;) # just used for cleanup </code></pre>
<div id="side-note" class="section level2">
<h2>Side note</h2>
<p>Throughout this tutorial, I may be re-reading in data using <code>antsImageRead</code>. This is due to the nature of the <code>antsImage</code> class. It represents the data as a pointer in memory. As I’m running RMarkdown and knitting the document, different chunks are necessarily going to keep the pointers, especially if one chunk was run in one session and then R was restarted. It’s a somewhat technical issue, but that is why I keep calling <code>antsImageRead</code> even when it seems as though that object is in memory in an earlier code chunk.</p>
</div>
</div>
<div id="stabilization-of-signal" class="section level1">
<h1>Stabilization of Signal</h1>
<p>Volumes corresponding to the first 10 seconds of the rs-fMRI scan were dropped to allow for magnetization stabilization.</p>
<pre class="r"><code>library(extrantsr)
library(oro.nifti)
library(ANTsR)
ants_fmri = antsImageRead(fmri_fname)
tr = 2 # 2 seconds
first_scan = floor(10.0 / tr) + 1 # 10 seconds &quot;stabilization of signal&quot;
sub_fmri = extrantsr::subset_4d(ants_fmri, first_scan:ntim(ants_fmri))</code></pre>
</div>
<div id="motion-correction" class="section level1">
<h1>Motion Correction</h1>
<p>Here we will average over the fMRI to get an average 3D image. We then run <code>antsMotionCalculation</code> to perform a rigid registration to the average image. We will then save those images and the parameters out to files.</p>
<pre class="r"><code>library(dplyr)
library(neurobase)
library(ANTsR)
base_fname = nii.stub(fmri_fname, bn = TRUE)
avg_img = getAverageOfTimeSeries(sub_fmri)

#####################
# Full with Half Max twice the vox size
##################
all_vox_dim = voxdim(sub_fmri)


#####################
# Motion Calculation
##################
moco_file = paste0(base_fname, 
                   &quot;_Motion_Params.rda&quot;)
moco_fname = paste0(base_fname, &quot;_moco_img.nii.gz&quot;)
if (all(file.exists(c(moco_file, 
                      moco_fname)))) { 
  load(moco_file)
  moco_img = antsImageRead(moco_fname)
  motion_res$moco_img = 
    moco_img
} else {
  motion_res = 
    antsMotionCalculation(sub_fmri, 
                          fixed = avg_img, 
                          moreaccurate = 1,
                          txtype = &quot;Rigid&quot;,
                          verbose = TRUE)
  save(motion_res, 
       file = moco_file)
  moco_img = 
    motion_res$moco_img
  antsImageWrite(moco_img, 
                 filename = moco_fname)
}
moco_params = 
    motion_res$moco_params
moco_params = moco_params %&gt;% 
    select(starts_with(&quot;MOCO&quot;))</code></pre>
<pre><code>Warning: failed to assign NativeSymbolInfo for env since env is already
defined in the &#39;lazyeval&#39; namespace</code></pre>
<pre class="r"><code>nuisanceVariables = moco_params
mp = round(moco_params, 4)
print(head(mp, 3))</code></pre>
<pre><code>  MOCOparam1 MOCOparam2 MOCOparam3 MOCOparam4 MOCOparam5 MOCOparam6
1    -0.0005      1e-04      5e-04     0.0865     0.5525    -0.0518
2    -0.0011     -7e-04      5e-04     0.1347     0.5654    -0.0497
3    -0.0005      0e+00      5e-04     0.0897     0.5595    -0.0428</code></pre>
<pre class="r"><code>rm(list = c(&quot;mp&quot;))</code></pre>
<div id="plotting-the-motion-parameters" class="section level3">
<h3>Plotting the motion parameters</h3>
<p>Here we will multiply the 3 first motion parameters (roll, pitch, yaw) by 50 to convert radians to millimeters by assuming a brain radius of 50 mm, as similar to <span class="citation">Power et al. (2012)</span>. The next 3 parameters are in terms of millimeters (x, y, z). We will plot each of the parameters on the same scale to look at the motion for each scan.</p>
<pre class="r"><code>mp = moco_params
mp[, 1:3] = mp[, 1:3] * 50
r = range(mp)
plot(mp[,1], type = &quot;l&quot;, xlab = &quot;Scan Number&quot;, main = &quot;Motion Parameters&quot;,
     ylab = &quot;Displacement (mm)&quot;,
     ylim = r * 1.25, 
     lwd = 2,
     cex.main = 2,
     cex.lab = 1.5,
     cex.axis = 1.25)
for (i in 2:ncol(mp)) {
  lines(mp[, i], col = i)
}</code></pre>
<p><img src="index_files/figure-html/moco_run_plot-1.png" /><!-- --></p>
<pre class="r"><code>rm(list = &quot;mp&quot;)</code></pre>
</div>
<div id="lets-make-a-matrix" class="section level2">
<h2>Let’s Make a Matrix!</h2>
<p><code>timeseries2matrix</code> creates <span class="math inline">\(T\times V\)</span> matrix, <span class="math inline">\(V\)</span> voxels in mask. We will get the average of the co-registered image. We wil use this average image to get a mask using the <code>getMask</code> function. We will then zero out the average image using the mask image.</p>
<pre class="r"><code>moco_img = antsImageRead(moco_fname)
moco_avg_img = 
    getAverageOfTimeSeries(moco_img)
maskImage = getMask(moco_avg_img, 
    mean(moco_avg_img), 
    Inf, cleanup = 2)
mask_fname = paste0(base_fname, &quot;_mask.nii.gz&quot;)
antsImageWrite(maskImage, filename = mask_fname)
double_ortho(moco_avg_img, maskImage, 
  col.y = &quot;white&quot;)</code></pre>
<p><img src="index_files/figure-html/ts_run-1.png" /><!-- --></p>
<pre class="r"><code>moco_avg_img[maskImage == 0] = 0
boldMatrix = timeseries2matrix(
    moco_img, 
    maskImage)</code></pre>
<div id="calculation-of-dvars" class="section level3">
<h3>Calculation of DVARS</h3>
<p>With this <code>boldMatrix</code>, we can calculate a series of information. For example, we can calculate DVARS based on the motion corrected data. We can also compare the DVARS to the DVARS calculated from the non-realigned data.</p>
<pre class="r"><code>dvars = computeDVARS(boldMatrix)
uncorr_dvars = motion_res$dvars
plot(dvars, uncorr_dvars,
  xlab = &quot;Realigned DVARS&quot;,
  ylab = &quot;Non-Realigned DVARS&quot;)
abline( a = 0, b = 1, col = &quot;red&quot;)</code></pre>
<p><img src="index_files/figure-html/compute_dvars-1.png" /><!-- --></p>
<p>We see that the realigned DVARS are lower for each image after coregistration.</p>
</div>
<div id="framewise-displacement" class="section level3">
<h3>Framewise Displacement</h3>
<p>Similarly for framewise displacement (FD), we can calculate the global FD as computed in <span class="citation">Power et al. (2012)</span>.</p>
<pre class="r"><code>mp = moco_params
mp[, 1:3] = mp[, 1:3] * 50
mp = apply(mp, 2, diff)
mp = rbind(rep(0, 6), mp)
mp = abs(mp)
fd = rowSums(mp)
plot(fd, type =&quot;h&quot;, 
  xlab = &quot;Scan&quot;, ylab = &quot;FD&quot;)</code></pre>
</div>
<div id="heatmap-of-the-values" class="section level3">
<h3>Heatmap of the values</h3>
<p>We can look at the full trajectory of each voxel over each scan. We scaled the data (by column, which is voxel), which is somewhat equivalent to doing whole-brain z-score normalization of the fMRI.</p>
<p>We can find the index which has the highest mean value, which may indicate some motion artifact.</p>
<pre class="r"><code>library(RColorBrewer)
library(matrixStats)
rf &lt;- colorRampPalette(rev(brewer.pal(11,&#39;Spectral&#39;)))
r &lt;- rf(32)
mat = scale(boldMatrix)
image(x = 1:nrow(mat), 
      y = 1:ncol(mat), 
      mat, useRaster=TRUE, 
      col = r,
      xlab = &quot;Scan Number&quot;, ylab = &quot;Voxel&quot;,
      main = paste0(&quot;Dimensions: &quot;, 
                    dim(mat)[1], &quot;×&quot;, dim(mat)[2]),
     cex.main = 2,
     cex.lab = 1.5,
     cex.axis = 1.25)
rmeans = rowMeans(mat)
bad_ind = which.max(rmeans)
print(bad_ind)</code></pre>
<pre><code>[1] 174</code></pre>
<pre class="r"><code>abline(v = bad_ind)</code></pre>
<p><img src="index_files/figure-html/ts_heatmap-1.png" /><!-- --></p>
<pre class="r"><code>sds = rowSds(mat)
print(which.max(sds))</code></pre>
<pre><code>[1] 174</code></pre>
<pre class="r"><code>rm(list = &quot;mat&quot;)</code></pre>
<pre class="r"><code>library(animation)
ani.options(autobrowse = FALSE)
gif_name = &quot;bad_dimension.gif&quot;
if (!file.exists(gif_name)) {
  arr = as.array(moco_img)
  pdim = pixdim(moco_img)
  saveGIF({
    for (i in seq(bad_ind - 1, bad_ind + 1)) {
      ortho2(arr[,,,i], pdim = pdim, text = i)
    }
  }, movie.name = gif_name)
}</code></pre>
<div class="figure">
<img src="bad_dimension.gif" />

</div>
</div>
</div>
</div>
<div id="nuisance-variables-compcor" class="section level1">
<h1>Nuisance Variables: CompCor</h1>
<p>In order to reduce some of these artifacts, there are numerous methods that exist. One of those methods is described as CompCor or components correction. In the implementation in ANTsR, <code>compcor</code> is described as PCA on high-variance voxels <span class="citation">(Behzadi et al. 2007)</span>.</p>
<p>You must specify the number of components you want to use (not necessarily variance explained).</p>
<pre class="r"><code>library(reshape2)
library(ggplot2)
ccor_file = paste0(base_fname, 
    &quot;_CompCor.rda&quot;)
if (all(file.exists(ccor_file))) { 
    load(ccor_file)
} else {
    highvar = compcor(
        moco_img, 
        maskImage, 
        ncompcor = 6, 
        variance_extreme = 0.975,
        returnhighvarmatinds = TRUE)
    compCorNuisanceVariables = compcor(
        moco_img, 
        maskImage, 
        ncompcor = 6, 
        variance_extreme = 0.975)
    save(compCorNuisanceVariables, 
        highvar,
        file = ccor_file)
}
n = ncol(compCorNuisanceVariables)
r = range(compCorNuisanceVariables)
long = reshape2::melt(compCorNuisanceVariables)
colnames(long) = c(&quot;scan_num&quot;, &quot;component&quot;, &quot;value&quot;)

ggplot(long, aes(x = scan_num, y = value)) + geom_line() + facet_wrap(~component, ncol = 1)</code></pre>
<p><img src="index_files/figure-html/ccor_run-1.png" /><!-- --></p>
</div>
<div id="session-info" class="section level1">
<h1>Session Info</h1>
<pre class="r"><code>devtools::session_info()</code></pre>
<pre><code>Session info -------------------------------------------------------------</code></pre>
<pre><code> setting  value                       
 version  R version 3.3.1 (2016-06-21)
 system   x86_64, darwin13.4.0        
 ui       X11                         
 language (EN)                        
 collate  en_US.UTF-8                 
 tz       America/New_York            
 date     2016-12-21                  </code></pre>
<pre><code>Packages -----------------------------------------------------------------</code></pre>
<pre><code> package      * version     date       source                             
 abind          1.4-5       2016-07-21 cran (@1.4-5)                      
 animation    * 2.4         2015-08-16 CRAN (R 3.2.0)                     
 ANTsR        * 0.3.3       2016-11-17 Github (stnava/ANTsR@063700b)      
 assertthat     0.1         2013-12-06 CRAN (R 3.2.0)                     
 backports      1.0.4       2016-10-24 CRAN (R 3.3.0)                     
 bitops         1.0-6       2013-08-17 CRAN (R 3.2.0)                     
 colorout     * 1.1-0       2015-04-20 Github (jalvesaq/colorout@1539f1f) 
 colorspace     1.3-0       2016-11-10 CRAN (R 3.3.2)                     
 DBI            0.5-1       2016-09-10 CRAN (R 3.3.0)                     
 devtools       1.12.0.9000 2016-12-08 Github (hadley/devtools@1ce84b0)   
 digest         0.6.10      2016-08-02 cran (@0.6.10)                     
 dplyr        * 0.5.0       2016-06-24 CRAN (R 3.3.0)                     
 evaluate       0.10        2016-10-11 CRAN (R 3.3.0)                     
 ggplot2      * 2.2.0       2016-11-11 CRAN (R 3.3.2)                     
 gtable         0.2.0       2016-02-26 CRAN (R 3.2.3)                     
 htmltools      0.3.6       2016-12-08 Github (rstudio/htmltools@4fbf990) 
 kirby21.base * 1.4.2       2016-10-05 local                              
 kirby21.fmri * 1.4         2016-09-29 local (@1.4)                       
 knitr          1.15.1      2016-11-22 cran (@1.15.1)                     
 lattice        0.20-34     2016-09-06 CRAN (R 3.3.0)                     
 lazyeval       0.2.0       2016-06-12 CRAN (R 3.3.0)                     
 magrittr       1.5         2014-11-22 CRAN (R 3.2.0)                     
 matrixStats  * 0.51.0      2016-10-09 cran (@0.51.0)                     
 memoise        1.0.0       2016-01-29 CRAN (R 3.2.3)                     
 munsell        0.4.3       2016-02-13 CRAN (R 3.2.3)                     
 neurobase    * 1.9.1       2016-12-21 local                              
 oro.nifti    * 0.7.2       2016-12-21 Github (bjw34032/oro.nifti@a713047)
 pkgbuild       0.0.0.9000  2016-12-08 Github (r-pkgs/pkgbuild@65eace0)   
 pkgload        0.0.0.9000  2016-12-08 Github (r-pkgs/pkgload@def2b10)    
 plyr           1.8.4       2016-06-08 CRAN (R 3.3.0)                     
 R.methodsS3  * 1.7.1       2016-02-16 CRAN (R 3.2.3)                     
 R.oo         * 1.21.0      2016-11-01 cran (@1.21.0)                     
 R.utils      * 2.5.0       2016-11-07 cran (@2.5.0)                      
 R6             2.2.0       2016-10-05 cran (@2.2.0)                      
 RColorBrewer * 1.1-2       2014-12-07 CRAN (R 3.2.0)                     
 Rcpp           0.12.8.2    2016-12-08 Github (RcppCore/Rcpp@8c7246e)     
 reshape2     * 1.4.2       2016-10-22 CRAN (R 3.3.0)                     
 rmarkdown      1.2.9000    2016-12-08 Github (rstudio/rmarkdown@7a3df75) 
 RNifti         0.3.0       2016-12-08 cran (@0.3.0)                      
 rprojroot      1.1         2016-10-29 cran (@1.1)                        
 scales         0.4.1       2016-11-09 CRAN (R 3.3.2)                     
 stringi        1.1.2       2016-10-01 CRAN (R 3.3.0)                     
 stringr        1.1.0       2016-08-19 cran (@1.1.0)                      
 tibble         1.2         2016-08-26 CRAN (R 3.3.0)                     
 withr          1.0.2       2016-06-20 CRAN (R 3.3.0)                     
 yaml           2.1.14      2016-11-12 CRAN (R 3.3.2)                     
 zoo          * 1.7-13      2016-05-03 CRAN (R 3.2.4)                     </code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-behzadi2007component">
<p>Behzadi, Yashar, Khaled Restom, Joy Liau, and Thomas T Liu. 2007. “A Component Based Noise Correction Method (Compcor) for Bold and Perfusion Based FMRI.” <em>Neuroimage</em> 37 (1). Elsevier: 90–101.</p>
</div>
<div id="ref-power2012spurious">
<p>Power, Jonathan D, Kelly A Barnes, Abraham Z Snyder, Bradley L Schlaggar, and Steven E Petersen. 2012. “Spurious but Systematic Correlations in Functional Connectivity Mri Networks Arise from Subject Motion.” <em>Neuroimage</em> 59 (3). Elsevier: 2142–54.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
