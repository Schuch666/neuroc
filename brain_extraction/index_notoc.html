<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>







</head>

<body>







<p>All code for this document is located at <a href="https://raw.githubusercontent.com/muschellij2/neuroc/master/brain_extraction/index.R">here</a>.</p>
<p>In this tutorial we will discuss performing brain segmentation using the brain extraction tool (BET) in <code>fsl</code> and a robust version using a wrapper function in <code>extrantsr</code>, <code>fslbet_robust</code>.</p>
<div id="data-packages" class="section level1">
<h1>Data Packages</h1>
<p>For this analysis, I will use one subject from the Kirby 21 data set. The <code>kirby21.base</code> and <code>kirby21.fmri</code> packages are necessary for this analysis and have the data we will be working on. You need devtools to install these. Please refer to <a href="neuroc-help-installing-devtools">installing devtools</a> for additional instructions or troubleshooting.</p>
<pre class="r"><code>packages = installed.packages()
packages = packages[, &quot;Package&quot;]
if (!&quot;kirby21.base&quot; %in% packages) {
  devtools::install_github(&quot;muschellij2/kirby21.base&quot;)
}
if (!&quot;kirby21.t1&quot; %in% packages) {
  devtools::install_github(&quot;muschellij2/kirby21.t1&quot;)
}</code></pre>
<div id="loading-data" class="section level2">
<h2>Loading Data</h2>
<p>We will use the <code>get_image_filenames_df</code> function to extract the filenames on our hard disk for the T1 image.</p>
<pre class="r"><code>library(kirby21.t1)
library(kirby21.base)
fnames = get_image_filenames_df(ids = 113, 
                    modalities = c(&quot;T1&quot;), 
                    visits = c(1),
                    long = FALSE)
t1_fname = fnames$T1[1]</code></pre>
</div>
</div>
<div id="t1-image" class="section level1">
<h1>T1 image</h1>
<p>Let’s take a look at the T1-weighted image.</p>
<pre class="r"><code>t1 = readnii(t1_fname)
ortho2(t1)</code></pre>
<p><img src="index_files/figure-html/t1_plot-1.png" /><!-- --></p>
<pre class="r"><code>rm(list = &quot;t1&quot;)</code></pre>
<p>Here we see the brain and other parts of the image are present. Most notably, the neck of the subject was imaged. Sometimes this can cause problems with segmentation and image registration.</p>
</div>
<div id="attempt-1-brain-extraction-of-t1-image-using-bet" class="section level1">
<h1>Attempt 1: Brain Extraction of T1 image using BET</h1>
<p>Here we will use FSL’s Brain Extraction Tool (BET) to extract the brain tissue from the rest of the image.</p>
<pre class="r"><code>library(fslr)
outfile = nii.stub(t1_fname, bn = TRUE)
outfile = paste0(outfile, &quot;_SS_Naive.nii.gz&quot;)
if (!file.exists(outfile)) {
  ss_naive = fslbet(infile = t1_fname, outfile = outfile)
} else {
  ss_naive = readnii(outfile)
}</code></pre>
<pre class="r"><code>ortho2(ss_naive)</code></pre>
<p><img src="index_files/figure-html/t1_naive_plot-1.png" /><!-- --></p>
<p>We see that naively, BET does not perform well for this image.</p>
</div>
<div id="brain-extraction-of-t1-image-using-bet" class="section level1">
<h1>Brain Extraction of T1 image using BET</h1>
<p>Here we will use FSL’s Brain Extraction Tool (BET) to extract the brain tissue from the rest of the image. We use the modification of BET in <code>extrantsr</code>, which is called through <code>fslbet_robust</code>. In <code>fslbet_robust</code>, the image is corrected using the N4 inhomogeneity correction. The neck of the T1 image is then removed and then BET is run, the center of gravity (COG) is estimated, and BET is run with this new COG. We used a procedure where the neck is removed in 2 registration steps, which is more robust than just the one (which is the default).</p>
<pre class="r"><code>outfile = nii.stub(t1_fname, bn = TRUE)
outfile = paste0(outfile, &quot;_SS.nii.gz&quot;)
if (!file.exists(outfile)) {
  ss = extrantsr::fslbet_robust(t1_fname, 
    remover = &quot;double_remove_neck&quot;,
    outfile = outfile)
} else {
  ss = readnii(outfile)
}</code></pre>
<p>Let’s look at the skull-stripped image.</p>
<pre class="r"><code>ortho2(ss)</code></pre>
<p><img src="index_files/figure-html/t1_ss_plot-1.png" /><!-- --></p>
<p>Here we see the skull-stripped image. But did we drop out “brain areas”?</p>
<pre class="r"><code>alpha = function(col, alpha = 1) {
  cols = t(col2rgb(col, alpha = FALSE)/255)
  rgb(cols, alpha = alpha)
}      
ortho2(t1_fname, ss &gt; 0, col.y = alpha(&quot;red&quot;, 0.5))</code></pre>
<p><img src="index_files/figure-html/t1_ss_plot2-1.png" /><!-- --></p>
<p>We can again use <code>dropEmptyImageDimensions</code> to remove extraneous slices, which helps with reducing storage of the image on disk, zooming in while plotting, and may aid registration.</p>
<pre class="r"><code>ss_red = dropEmptyImageDimensions(ss)
ortho2(ss_red)</code></pre>
<p><img src="index_files/figure-html/t1_ss_red-1.png" /><!-- --></p>
<p>Again, we can see the zoomed-in view of the image now.</p>
</div>
<div id="brain-extraction-of-t1-image-using-spm" class="section level1">
<h1>Brain Extraction of T1 image using SPM</h1>
<p>Note, to use SPM12, you must have MATLAB. We will use the <code>spm12r</code> package, which calls the <code>matlabr</code> package to call SPM functions within MATLAB.</p>
<pre class="r"><code>library(spm12r)</code></pre>
<p>The <code>spm12_segment</code> function takes in the original image and will perform segmentation on the entire image (background, skull, etc). The result of <code>spm12_segment</code> is a list of length 6 with a probability for each tissue type. The order of them is gray matter (GM), white matter (WM), and cerebrospinal fluid (CSF). We will create a brain mask from these first 3 classes. We can convert the probabilities to a hard segmentation using <code>spm_probs_to_seg</code>, which takes the maximum class probability to assign the class for each voxel. There are additional options for ties, but the default is to use the first class (GM &gt; WM &gt; CSF).</p>
<pre class="r"><code>outfile = nii.stub(t1_fname, bn = TRUE)
spm_prob_files = paste0(outfile,
                        &quot;_prob_&quot;, 1:6,
                        &quot;.nii.gz&quot;)
ss_outfile = paste0(outfile, &quot;_SPM_SS.nii.gz&quot;)
outfile = paste0(outfile, &quot;_SPM_Seg.nii.gz&quot;)
outfiles = c(outfile, ss_outfile, spm_prob_files)
if (!all(file.exists(outfiles))) {
  spm_seg = spm12_segment(t1_fname)
  spm_hard_seg = spm_probs_to_seg(img = spm_seg)
  writenii(spm_hard_seg, filename = outfile)
  
  spm_ss = spm_hard_seg &gt;= 1 &amp; spm_hard_seg &lt;= 3
  writenii(spm_ss, filename = ss_outfile)
  
  for (i in seq_along(spm_seg)) {
    writenii(spm_seg[[i]], spm_prob_files[i]) 
  }  
} else {
  spm_seg = vector(mode = &quot;list&quot;, 
                   length = length(spm_prob_files))
  for (i in seq_along(spm_seg)) {
    spm_seg[[i]] = readnii(spm_prob_files[i]) 
  }
  spm_hard_seg = readnii(outfile)
  spm_ss = readnii(ss_outfile)
}</code></pre>
<div id="results-of-spm-tissue-segmentation" class="section level2">
<h2>Results of SPM Tissue Segmentation</h2>
<pre class="r"><code>double_ortho(t1_fname, spm_hard_seg)</code></pre>
<p><img src="index_files/figure-html/t1_spm_seg_plot-1.png" /><!-- --></p>
</div>
<div id="results-of-spm-brain-segmentation" class="section level2">
<h2>Results of SPM Brain Segmentation</h2>
<p>Here we will show again the T1 image with the corresponding skull stripped mask in red.</p>
<pre class="r"><code>alpha = function(col, alpha = 1) {
  cols = t(col2rgb(col, alpha = FALSE)/255)
  rgb(cols, alpha = alpha)
}      
ortho2(t1_fname, spm_ss &gt; 0, col.y = alpha(&quot;red&quot;, 0.5))</code></pre>
<p><img src="index_files/figure-html/t1_spm_ss-1.png" /><!-- --></p>
</div>
<div id="additional-preprocessing-to-do" class="section level2">
<h2>Additional Preprocessing to do</h2>
<p>We can also remove the neck of the image and rerun the segmentation. We will run the <code>double_remove_neck</code> function to perform this.</p>
<pre class="r"><code>outfile = nii.stub(t1_fname, bn = TRUE)
outfile = paste0(outfile,
                 &quot;_noneck.nii.gz&quot;)
if (!file.exists(outfile)) {
  noneck = extrantsr::double_remove_neck(
    t1_fname,
    template.file = file.path(fslr::fsldir(), &quot;data/standard&quot;,
                              &quot;MNI152_T1_1mm_brain.nii.gz&quot;), 
    template.mask = file.path(fslr::fsldir(),
                              &quot;data/standard&quot;, 
                              &quot;MNI152_T1_1mm_brain_mask.nii.gz&quot;))
  writenii(noneck, filename = outfile)
} else {
  noneck = readnii(outfile)
}</code></pre>
<p>Here we see that most of the neck was truly removed from the original image.</p>
<pre class="r"><code>double_ortho(t1_fname, noneck)</code></pre>
<p><img src="index_files/figure-html/noneck_plot-1.png" /><!-- --></p>
<div id="dropping-empty-image-dimensions" class="section level3">
<h3>Dropping empty image dimensions</h3>
<p>Now we will drop the neck slices using <code>dropEmptyImageDimensions</code> again:</p>
<pre class="r"><code>noneck_red = dropEmptyImageDimensions(noneck)
ortho2(noneck_red)</code></pre>
<p><img src="index_files/figure-html/reduce_noneck-1.png" /><!-- --></p>
<pre class="r"><code>library(spm12r)
outfile = nii.stub(t1_fname, bn = TRUE)
outfile = paste0(outfile, &quot;_noneck&quot;)
spm_prob_files = paste0(outfile,
                        &quot;_prob_&quot;, 1:6,
                        &quot;.nii.gz&quot;)
ss_outfile = paste0(outfile, &quot;_SPM_SS.nii.gz&quot;)
outfile = paste0(outfile, &quot;_SPM_Seg.nii.gz&quot;)
outfiles = c(outfile, ss_outfile, spm_prob_files)
if (!all(file.exists(outfiles))) {
  nn_spm_seg = spm12_segment(noneck_red)
  nn_spm_hard_seg = spm_probs_to_seg(img = nn_spm_seg)
  writenii(nn_spm_hard_seg, filename = outfile)
  
  nn_spm_ss = nn_spm_hard_seg &gt;= 1 &amp; nn_spm_hard_seg &lt;= 3
  writenii(nn_spm_ss, filename = ss_outfile)
  
  for (i in seq_along(nn_spm_seg)) {
    writenii(nn_spm_seg[[i]], spm_prob_files[i]) 
  }  
} else {
  nn_spm_seg = vector(mode = &quot;list&quot;, 
                   length = length(spm_prob_files))
  for (i in seq_along(nn_spm_seg)) {
    nn_spm_seg[[i]] = readnii(spm_prob_files[i]) 
  }
  nn_spm_hard_seg = readnii(outfile)
  nn_spm_ss = readnii(ss_outfile)
}</code></pre>
</div>
</div>
<div id="results-of-spm-tissue-segmentation-1" class="section level2">
<h2>Results of SPM Tissue Segmentation</h2>
<pre class="r"><code>double_ortho(noneck_red, nn_spm_hard_seg)</code></pre>
<p><img src="index_files/figure-html/t1_nn_spm_seg_plot-1.png" /><!-- --></p>
</div>
<div id="results-of-spm-brain-segmentation-1" class="section level2">
<h2>Results of SPM Brain Segmentation</h2>
<p>Here we will show again the T1 image with the corresponding skull stripped mask in red.</p>
<pre class="r"><code>ortho2(noneck_red, nn_spm_ss &gt; 0, col.y = alpha(&quot;red&quot;, 0.5))</code></pre>
<p><img src="index_files/figure-html/t1_nn_spm_ss-1.png" /><!-- --></p>
<p>In order to compare this segmentation to that of the full brain, we must make the dimensions equal again. We will use the <code>replace_dropped_dimensions</code> to do this.</p>
<pre class="r"><code>dd = dropEmptyImageDimensions(noneck, keep_ind = TRUE)
nn_spm_ss_full = replace_dropped_dimensions(img = nn_spm_ss,
                                            inds = dd$inds,
                                            orig.dim = dd$orig.dim)</code></pre>
<pre class="r"><code>ortho2(t1_fname, nn_spm_ss_full, col.y = alpha(&quot;red&quot;, 0.5))</code></pre>
<p><img src="index_files/figure-html/t1_nn_ss_plot_full-1.png" /><!-- --></p>
<p>Here, if we assume the original skull stripped image as the gold standard and the one from the neck removal as another “prediction”, we can look at the differences. Anywhere they both agree (both are a 1) it will be deemed a true positive and will be in green. Anywhere the neck-removed segmentation includes a voxel but the neck-included segmentation did not, it will deemed a false positive and will be in blue, vice versa in red will be a false negative.</p>
<pre class="r"><code>ortho_diff(t1_fname, pred = nn_spm_ss_full, roi = spm_ss)</code></pre>
<pre><code>Warning in max(img, na.rm = TRUE): no non-missing arguments to max;
returning -Inf</code></pre>
<pre><code>Warning in min(img, na.rm = TRUE): no non-missing arguments to min;
returning Inf</code></pre>
<pre><code>Warning in max(img, na.rm = TRUE): no non-missing arguments to max;
returning -Inf</code></pre>
<pre><code>Warning in min(img, na.rm = TRUE): no non-missing arguments to min;
returning Inf</code></pre>
<p><img src="index_files/figure-html/spm_diff-1.png" /><!-- --></p>
<p>Here we see that for brain segmentation, there was not a large effect of removing the neck.</p>
</div>
</div>
<div id="comparison-of-bet-and-spm" class="section level1">
<h1>Comparison of BET and SPM</h1>
<p>Here we will compare the results from SPM and BET similarly to those above. Just for simplicity and comparison above, we will use the “prediction” as the BET skull-stripped mask and keep the SPM image as the “gold standard”/“truth” to keep the interpretation of the colors the same. Just insert “BET” above instead of “neck-removed segmentation”.</p>
<pre class="r"><code>ortho_diff(t1_fname, pred = ss, roi = spm_ss)</code></pre>
<pre><code>Warning in max(img, na.rm = TRUE): no non-missing arguments to max;
returning -Inf</code></pre>
<pre><code>Warning in min(img, na.rm = TRUE): no non-missing arguments to min;
returning Inf</code></pre>
<pre><code>Warning in max(img, na.rm = TRUE): no non-missing arguments to max;
returning -Inf</code></pre>
<pre><code>Warning in min(img, na.rm = TRUE): no non-missing arguments to min;
returning Inf</code></pre>
<p><img src="index_files/figure-html/spm_bet_diff-1.png" /><!-- --></p>
<p>We see that the SPM segmentation includes some of the extracranial CSF, is a bit “smoother” on the surface, and includes some areas towards the bottom of the brain near the brain stem (more CSF). We also see on some areas of the surface, BET includes these as brain whereas SPM does not. If you are to compare the volume of the “brain” (in quotes because that may include non-tissue as CSF), you must keep these things in mind.</p>
</div>
<div id="session-info" class="section level1">
<h1>Session Info</h1>
<pre class="r"><code>devtools::session_info()</code></pre>
<pre><code>Session info --------------------------------------------------------------</code></pre>
<pre><code> setting  value                       
 version  R version 3.3.1 (2016-06-21)
 system   x86_64, darwin13.4.0        
 ui       X11                         
 language (EN)                        
 collate  en_US.UTF-8                 
 tz       America/New_York            
 date     2016-11-09                  </code></pre>
<pre><code>Packages ------------------------------------------------------------------</code></pre>
<pre><code> package      * version date       source                              
 abind          1.4-5   2016-07-21 cran (@1.4-5)                       
 animation    * 2.4     2015-08-16 CRAN (R 3.2.0)                      
 ANTsR        * 0.3.3   2016-10-10 Github (stnava/ANTsR@a50e986)       
 assertthat     0.1     2013-12-06 CRAN (R 3.2.0)                      
 bitops         1.0-6   2013-08-17 CRAN (R 3.2.0)                      
 codetools      0.2-14  2015-07-15 CRAN (R 3.3.1)                      
 colorout     * 1.1-0   2015-04-20 Github (jalvesaq/colorout@1539f1f)  
 colorspace     1.2-6   2015-03-11 CRAN (R 3.2.0)                      
 DBI            0.5-1   2016-09-10 CRAN (R 3.3.0)                      
 devtools       1.12.0  2016-06-24 CRAN (R 3.3.0)                      
 digest         0.6.10  2016-08-02 cran (@0.6.10)                      
 dplyr        * 0.5.0   2016-06-24 CRAN (R 3.3.0)                      
 evaluate       0.9     2016-04-29 CRAN (R 3.2.5)                      
 extrantsr    * 2.5     2016-10-31 local                               
 formatR        1.4     2016-05-09 CRAN (R 3.2.5)                      
 fslr         * 2.4     2016-11-04 Github (muschellij2/fslr@7ce0f03)   
 ggplot2      * 2.1.0   2016-03-01 CRAN (R 3.3.0)                      
 git2r          0.15.0  2016-05-11 CRAN (R 3.3.0)                      
 gtable         0.2.0   2016-02-26 CRAN (R 3.2.3)                      
 hash           2.2.6   2013-02-21 CRAN (R 3.2.0)                      
 htmltools      0.3.6   2016-09-26 Github (rstudio/htmltools@6996430)  
 igraph         1.0.1   2015-06-26 CRAN (R 3.2.0)                      
 iterators      1.0.8   2015-10-13 CRAN (R 3.2.0)                      
 kirby21.base * 1.4.2   2016-10-05 local                               
 kirby21.fmri * 1.4     2016-09-29 local (@1.4)                        
 kirby21.t1   * 1.4     2016-09-29 local                               
 knitr          1.14    2016-08-13 CRAN (R 3.3.0)                      
 lattice        0.20-34 2016-09-06 CRAN (R 3.3.0)                      
 magrittr       1.5     2014-11-22 CRAN (R 3.2.0)                      
 matlabr        1.1.3   2016-07-12 Github (muschellij2/matlabr@57d5408)
 Matrix         1.2-7.1 2016-09-01 CRAN (R 3.3.0)                      
 matrixStats  * 0.51.0  2016-10-09 cran (@0.51.0)                      
 memoise        1.0.0   2016-01-29 CRAN (R 3.2.3)                      
 mgcv           1.8-15  2016-09-14 CRAN (R 3.3.0)                      
 mmap           0.6-12  2013-08-28 CRAN (R 3.3.0)                      
 munsell        0.4.3   2016-02-13 CRAN (R 3.2.3)                      
 neurobase    * 1.5.1   2016-11-04 local                               
 neuroim        0.1.0   2016-09-27 local                               
 nlme           3.1-128 2016-05-10 CRAN (R 3.3.1)                      
 oro.nifti    * 0.6.2   2016-11-04 Github (bjw34032/oro.nifti@fe54c8e) 
 plyr           1.8.4   2016-06-08 CRAN (R 3.3.0)                      
 R.matlab       3.6.0   2016-07-05 CRAN (R 3.3.0)                      
 R.methodsS3  * 1.7.1   2016-02-16 CRAN (R 3.2.3)                      
 R.oo         * 1.20.0  2016-02-17 CRAN (R 3.2.3)                      
 R.utils      * 2.4.0   2016-09-14 cran (@2.4.0)                       
 R6             2.2.0   2016-10-05 cran (@2.2.0)                       
 RColorBrewer * 1.1-2   2014-12-07 CRAN (R 3.2.0)                      
 Rcpp           0.12.7  2016-09-05 cran (@0.12.7)                      
 reshape2     * 1.4.1   2014-12-06 CRAN (R 3.2.0)                      
 rmarkdown      1.1     2016-10-16 CRAN (R 3.3.1)                      
 RNifti         0.2.2   2016-10-02 cran (@0.2.2)                       
 scales         0.4.0   2016-02-26 CRAN (R 3.2.3)                      
 spm12r       * 2.0     2016-09-28 CRAN (R 3.3.0)                      
 stringi        1.1.1   2016-05-27 CRAN (R 3.3.0)                      
 stringr        1.1.0   2016-08-19 cran (@1.1.0)                       
 tibble         1.2     2016-08-26 CRAN (R 3.3.0)                      
 WhiteStripe    2.0     2016-09-28 local                               
 withr          1.0.2   2016-06-20 CRAN (R 3.3.0)                      
 yaImpute       1.0-26  2015-07-20 CRAN (R 3.2.0)                      
 yaml           2.1.13  2014-06-12 CRAN (R 3.2.0)                      
 zoo          * 1.7-13  2016-05-03 CRAN (R 3.2.4)                      </code></pre>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
