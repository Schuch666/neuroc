<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>

<link href="index_notoc_files/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="index_notoc_files/highlightjs-1.1/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>





</head>

<body>







<p>All code for this document is located at <a href="https://raw.githubusercontent.com/muschellij2/neuroc/master/fmri_analysis_fslr/index.R">here</a>.</p>
<pre class="r"><code>library(methods)
library(fslr)</code></pre>
<pre><code>Loading required package: oro.nifti</code></pre>
<pre><code>oro.nifti 0.7.2</code></pre>
<pre><code>Loading required package: neurobase</code></pre>
<pre class="r"><code>library(neurobase)
library(extrantsr)</code></pre>
<p>In this tutorial we will discuss performing some preprocessing of a single subject functional MRI in FSL.</p>
<div id="data-packages" class="section level1">
<h1>Data Packages</h1>
<p>For this analysis, I will use one subject from the Kirby 21 data set. The <code>kirby21.base</code> and <code>kirby21.fmri</code> packages are necessary for this analysis and have the data we will be working on. You need devtools to install these. Please refer to <a href="neuroc-help-installing-devtools">installing devtools</a> for additional instructions or troubleshooting.</p>
<pre class="r"><code>packages = installed.packages()
packages = packages[, &quot;Package&quot;]
if (!&quot;kirby21.base&quot; %in% packages) {
  devtools::install_github(&quot;muschellij2/kirby21.base&quot;)
}
if (!&quot;kirby21.fmri&quot; %in% packages) {
  devtools::install_github(&quot;muschellij2/kirby21.fmri&quot;)
}</code></pre>
</div>
<div id="loading-data" class="section level1">
<h1>Loading Data</h1>
<p>We will use the <code>get_image_filenames_df</code> function to extract the filenames on our hard disk for the T1 image and the fMRI images (4D).</p>
<pre class="r"><code>library(kirby21.fmri)
library(kirby21.base)
fnames = get_image_filenames_df(ids = 113, 
                    modalities = c(&quot;T1&quot;, &quot;fMRI&quot;), 
                    visits = c(1),
                    long = FALSE)
t1_fname = fnames$T1[1]
fmri_fname = fnames$fMRI[1]
base_fname = nii.stub(fmri_fname, bn = TRUE)</code></pre>
<div id="parameter-file" class="section level2">
<h2>Parameter file</h2>
<p>If you’d like to see the header information from the fMRI data, it is located by the following commands:</p>
<pre class="r"><code>library(R.utils)
par_file = system.file(&quot;visit_1/113/113-01-fMRI.par.gz&quot;, 
                       package = &quot;kirby21.fmri&quot;)
# unzip it
con = gunzip(par_file, temporary = TRUE, 
             remove = FALSE, overwrite = TRUE)
info = readLines(con = con)
info[11:23]</code></pre>
<pre><code> [1] &quot;.    Protocol name                      :   WIP Bold_Rest SENSE&quot;
 [2] &quot;.    Series Type                        :   Image   MRSERIES&quot;   
 [3] &quot;.    Acquisition nr                     :   11&quot;                 
 [4] &quot;.    Reconstruction nr                  :   1&quot;                  
 [5] &quot;.    Scan Duration [sec]                :   434&quot;                
 [6] &quot;.    Max. number of cardiac phases      :   1&quot;                  
 [7] &quot;.    Max. number of echoes              :   1&quot;                  
 [8] &quot;.    Max. number of slices/locations    :   37&quot;                 
 [9] &quot;.    Max. number of dynamics            :   210&quot;                
[10] &quot;.    Max. number of mixes               :   1&quot;                  
[11] &quot;.    Patient position                   :   Head First Supine&quot;  
[12] &quot;.    Preparation direction              :   Anterior-Posterior&quot; 
[13] &quot;.    Technique                          :   FEEPI&quot;              </code></pre>
<p>From the paper <a href="http://dx.doi.org/10.1016/j.neuroimage.2010.11.047">“Multi-parametric neuroimaging reproducibility: A 3-T resource study”</a>, which this data is based on, it describes the fMRI sequence:</p>
<blockquote>
<p>The sequence used for resting state functional connectivity MRI is typically identical to that used for BOLD functional MRI studies of task activation. Here, we used a 2D EPI sequence with SENSE partial-parallel imaging acceleration to obtain 3 × 3 mm (80 by 80 voxels) in-plane resolution in thirty-seven 3 mm transverse slices with 1 mm slice gap. An ascending slice order with TR/TE = 2000/30 ms, flip angle of 75°, and SENSE acceleration factor of 2 were used. SPIR was used for fat suppression. This study used an ascending slice acquisition order because a pilot studies revealed smaller motion induced artifacts with ascending slice order than with interleaved slice order. While using an ascending slice order, it was necessary to use a small slice gap to prevent cross talk between the slices. One 7-min run was recorded which provided 210 time points (discarding the first four volumes to achieve steady state).</p>
</blockquote>
</div>
</div>
<div id="outline" class="section level1">
<h1>Outline</h1>
<p>The steps I will perform in this analysis:</p>
<ol style="list-style-type: decimal">
<li>Calculation of Motion Parameters (<code>fslr::mcflirt</code>)</li>
<li>Slice timing correction (<code>fslr::fsl_slicetimer</code>), but we need to know how the scan was taken/slice order and repetition time (TR)</li>
<li>Motion Correction on Corrected Data (<code>fslr::mcflirt</code>)</li>
<li>Coregistration of fMRI and a T1-weighted image (<code>fslr::flirt</code>)</li>
<li>Registration to the Template space (<code>fslr::fnirt_with_affine</code> )</li>
<li>De-meaning the data (fslr::fslmean(ts = TRUE))</li>
<li>Skull stripping (fslr::fslbet)</li>
<li>Registration to a template using the T1 and then transforming the fMRI with it</li>
<li>Spatially smoothing the data (fslr:fslsmooth)</li>
<li>Tissue-class segmentation (fslr::fast, ANTsR::atropos or extrantsr::otropos)?</li>
<li>Bandpass/butterworth filtering (signal::butter, signal::buttord)</li>
<li>Get a connectivity matrix of certain regions, you need to specify an atlas.</li>
</ol>
<p>Now we know that the head is first in (as usual) and the data was acquired in ascending order (i.e. bottom -&gt; up) and the repetition time (TR) was 2 seconds The</p>
<pre class="r"><code>fmri = readnii(fmri_fname)
ortho2(fmri, w = 1, add.orient = FALSE)</code></pre>
<p><img src="index_files/figure-html/fmri-1.png" /><!-- --></p>
<pre class="r"><code>rm(list = &quot;fmri&quot;) # just used for cleanup </code></pre>
</div>
<div id="stabilization-of-signal" class="section level1">
<h1>Stabilization of Signal</h1>
<p>Volumes corresponding to the first 10 seconds of the rs-fMRI scan were dropped to allow for magnetization stabilization.</p>
<pre class="r"><code>fmri = readnii(fmri_fname)
tr = 2 # 2 seconds
first_scan = floor(10.0 / tr) + 1 # 10 seconds &quot;stabilization of signal&quot;
sub_fmri = subset_4d(fmri, first_scan:ntim(fmri))</code></pre>
</div>
<div id="slice-timing-correction" class="section level1">
<h1>Slice Timing Correction</h1>
<pre class="r"><code>library(fslr)
scorr_fname = paste0(base_fname, &quot;_scorr.nii.gz&quot;)
if (!file.exists(scorr_fname)) {
  scorr = fsl_slicetimer(file = sub_fmri, 
                 outfile = scorr_fname, 
                 tr = 2, direction = &quot;z&quot;, acq_order = &quot;contiguous&quot;,
                 indexing = &quot;up&quot;)
} else {
  scorr = readnii(scorr_fname)
}</code></pre>
</div>
<div id="slice-timing-correction-1" class="section level1">
<h1>Slice Timing Correction</h1>
<p>Similarly to the ANTsR processing, we can set <code>opts = &quot;-meanvol&quot;</code> so that the motion correction registers the images to the mean of the time series. The default otherwise is to register to the scan in the middle (closest to number of time points / 2). You can supercede this with either specifying <code>-refvol</code> for which time point to register to, or <code>-reffile</code> to specify a volume to register to. You can think of <code>-meanvol</code> as a wrapper for making the mean time series (using <code>fslmaths(opt = &quot;-Tmean&quot;)</code>) and then passing that in as a <code>reffile</code>. We will do this explicitly in the code below. The <code>-plots</code> arguments outputs a <code>.par</code> file so that we can read the motion parameters after <code>mcflirt</code> is run.</p>
<pre class="r"><code>moco_fname = paste0(base_fname, 
                    &quot;_motion_corr.nii.gz&quot;)
par_file = paste0(nii.stub(moco_fname), &quot;.par&quot;)
avg_fname = paste0(base_fname, 
                   &quot;_avg.nii.gz&quot;)
if (!file.exists(avg_fname)) {
  fsl_maths(file = sub_fmri, 
            outfile = avg_fname,
            opts = &quot;-Tmean&quot;)
}

if (!all(file.exists(c(moco_fname, par_file)))) {
  moco_img = mcflirt(
    file = sub_fmri, 
    outfile = moco_fname,
    verbose = 2,
    opts = paste0(&quot;-reffile &quot;, avg_fname, &quot; -plots&quot;)
  )
} else {
  moco_img = readnii(moco_fname)
}
moco_params = readLines(par_file)
moco_params = strsplit(moco_params, split = &quot; &quot;)
moco_params = sapply(moco_params, function(x) {
  as.numeric(x[ !(x %in% &quot;&quot;)])
})
moco_params = t(moco_params)
colnames(moco_params) = paste0(&quot;MOCOparam&quot;, 1:ncol(moco_params))
head(moco_params)</code></pre>
<pre><code>       MOCOparam1  MOCOparam2   MOCOparam3 MOCOparam4 MOCOparam5
[1,] -0.000309931 0.001248200 -4.26752e-04 0.03832110  -0.558039
[2,] -0.000650414 0.000826515 -5.37836e-04 0.03833610  -0.607328
[3,] -0.000581280 0.001141430 -4.26752e-04 0.03831010  -0.566965
[4,] -0.000906044 0.000826516 -4.26752e-04 0.02266840  -0.577867
[5,] -0.000188335 0.001106950 -1.23971e-04 0.01542600  -0.556718
[6,] -0.000605871 0.000849419 -6.14711e-06 0.00108561  -0.577868
     MOCOparam6
[1,]  0.0768606
[2,]  0.0589568
[3,]  0.0704959
[4,]  0.0465875
[5,]  0.0412824
[6,]  0.0439374</code></pre>
<div id="lets-make-a-matrix" class="section level2">
<h2>Let’s Make a Matrix!</h2>
<p><code>img_ts_to_matrix</code> creates <span class="math inline">\(V\times T\)</span> matrix, <span class="math inline">\(V\)</span> voxels in mask, unlike <code>ANTsR::timeseries2matrix</code>. Therefore, we transpose the matrix so that it is consistent with the <a href="neuroc-help-fmri-analysis-antsr">ANTsR tutorial for fMRI</a> and so <code>boldMatrix</code> is <span class="math inline">\(T\times V\)</span>. We will get the average of the co-registered image using <code>fslmaths</code>. We wil use this average image to get a mask using the <code>oMask</code> function, which calls <code>getMask</code>, but for <code>nifti</code> objects. We will then zero out the average image using the mask image.</p>
<pre class="r"><code>moco_avg_img = fslmaths(moco_fname, opts = &quot;-Tmean&quot;)</code></pre>
<pre><code>fslmaths &quot;/Users/johnmuschelli/Dropbox/Projects/neuroc/fmri_analysis_fslr/113-01-fMRI_motion_corr.nii.gz&quot;  -Tmean &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpsXJmUI/filea52947f11d2b&quot;;</code></pre>
<pre class="r"><code>maskImage = oMask(moco_avg_img, 
    mean(moco_avg_img), 
    Inf, cleanup = 2)
mask_fname = paste0(base_fname, &quot;_mask.nii.gz&quot;)
writenii(maskImage, filename = mask_fname)

bet_mask = fslbet(moco_avg_img) &gt; 0</code></pre>
<pre><code>bet2 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpsXJmUI/filea5291952d00f.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpsXJmUI/filea5292b13af31&quot; </code></pre>
<pre class="r"><code>bet_mask_fname = paste0(base_fname, &quot;_bet_mask.nii.gz&quot;)
writenii(bet_mask, filename = bet_mask_fname)</code></pre>
<p>We can also look at the differences. We will assume the <code>maskImage</code> as the “gold standard” and <code>bet_mask</code> to be the “prediction”.</p>
<pre class="r"><code>double_ortho(moco_avg_img, maskImage, 
  col.y = &quot;white&quot;)</code></pre>
<p><img src="index_files/figure-html/plot_masks-1.png" /><!-- --></p>
<pre class="r"><code>double_ortho(moco_avg_img, bet_mask, 
  col.y = &quot;white&quot;)</code></pre>
<p><img src="index_files/figure-html/plot_masks-2.png" /><!-- --></p>
<pre class="r"><code>ortho_diff( moco_avg_img, roi = maskImage, pred = bet_mask )</code></pre>
<pre><code>Warning in max(img, na.rm = TRUE): no non-missing arguments to max;
returning -Inf</code></pre>
<pre><code>Warning in min(img, na.rm = TRUE): no non-missing arguments to min;
returning Inf</code></pre>
<pre><code>Warning in max(img, na.rm = TRUE): no non-missing arguments to max;
returning -Inf</code></pre>
<pre><code>Warning in min(img, na.rm = TRUE): no non-missing arguments to min;
returning Inf</code></pre>
<p><img src="index_files/figure-html/plot_masks-3.png" /><!-- --></p>
<p>Here we will create a matrix of time by voxels.</p>
<pre class="r"><code>moco_avg_img[maskImage == 0] = 0
boldMatrix = img_ts_to_matrix(
    moco_img)
boldMatrix = t(boldMatrix)
boldMatrix = boldMatrix[ , maskImage == 1]</code></pre>
<div id="calculation-of-dvars" class="section level3">
<h3>Calculation of DVARS</h3>
<p>With this <code>boldMatrix</code>, we can calculate a series of information. For example, we can calculate DVARS based on the motion corrected data. We can also compare the DVARS to the DVARS calculated from the non-realigned data.</p>
<p>Here we show how you can still use <code>ANTsR::computeDVARS</code> to calculate DVARS. The first element of <code>dvars</code> is the mean of the <code>my_dvars</code>. By the definition of <span class="citation">@power2012spurious</span>, the first element of DVARS should be zero.</p>
<p>Here we will multiply the 3 first motion parameters (roll, pitch, yaw) by 50 to convert radians to millimeters by assuming a brain radius of 50 mm, as similar to <span class="citation">@power2012spurious</span>. The next 3 parameters are in terms of millimeters (x, y, z). We will plot each of the parameters on the same scale to look at the motion for each scan.</p>
<pre class="r"><code>dvars = ANTsR::computeDVARS(boldMatrix)
dMatrix = apply(boldMatrix, 2, diff)
dMatrix = rbind(rep(0, ncol(dMatrix)), dMatrix)
my_dvars = sqrt(rowMeans(dMatrix^2))
head(cbind(dvars = dvars, my_dvars = my_dvars))</code></pre>
<pre><code>        dvars my_dvars
[1,] 18861.75     0.00
[2,] 18335.35 18335.35
[3,] 18855.69 18855.69
[4,] 17292.62 17292.62
[5,] 18590.46 18590.46
[6,] 18375.67 18375.67</code></pre>
<pre class="r"><code>print(mean(my_dvars))</code></pre>
<pre><code>[1] 18861.75</code></pre>
<p>Similarly, we can calculate the marginal framewise displacement (FD). The rotation parameters are again in radians so we can translate these to millimeters based on a 50 mm radius of the head.</p>
<pre class="r"><code>mp = moco_params
mp[, 1:3] = mp[, 1:3] * 50
mp = apply(mp, 2, diff)
mp = rbind(rep(0, 6), mp)
mp = abs(mp)
fd = rowSums(mp)</code></pre>
<pre class="r"><code>mp = moco_params
mp[, 1:3] = mp[, 1:3] * 50
r = range(mp)
plot(mp[,1], type = &quot;l&quot;, xlab = &quot;Scan Number&quot;, main = &quot;Motion Parameters&quot;,
     ylab = &quot;Displacement (mm)&quot;,
     ylim = r * 1.25, 
     lwd = 2,
     cex.main = 2,
     cex.lab = 1.5,
     cex.axis = 1.25)
for (i in 2:ncol(mp)) {
  lines(mp[, i], col = i)
}</code></pre>
<p><img src="index_files/figure-html/moco_run_plot-1.png" /><!-- --></p>
<pre class="r"><code>rm(list = &quot;mp&quot;)</code></pre>
</div>
<div id="heatmap-of-the-values" class="section level3">
<h3>Heatmap of the values</h3>
<p>We can look at the full trajectory of each voxel over each scan. We scaled the data (by column, which is voxel), which is somewhat equivalent to doing whole-brain z-score normalization of the fMRI.</p>
<p>We can find the index which has the highest mean value, which may indicate some motion artifact.</p>
<pre class="r"><code>library(RColorBrewer)
library(matrixStats)
rf &lt;- colorRampPalette(rev(brewer.pal(11,&#39;Spectral&#39;)))
r &lt;- rf(32)
mat = scale(boldMatrix)
image(x = 1:nrow(mat), 
      y = 1:ncol(mat), 
      mat, useRaster = TRUE, 
      col = r,
      xlab = &quot;Scan Number&quot;, ylab = &quot;Voxel&quot;,
      main = paste0(&quot;Dimensions: &quot;, 
                    dim(mat)[1], &quot;×&quot;, dim(mat)[2]),
     cex.main = 2,
     cex.lab = 1.5,
     cex.axis = 1.25)
rmeans = rowMeans(mat)
bad_ind = which.max(rmeans)
print(bad_ind)</code></pre>
<pre><code>[1] 174</code></pre>
<pre class="r"><code>abline(v = bad_ind)</code></pre>
<p><img src="index_files/figure-html/ts_heatmap-1.png" /><!-- --></p>
<pre class="r"><code>sds = rowSds(mat)
print(which.max(sds))</code></pre>
<pre><code>[1] 174</code></pre>
<pre class="r"><code>rm(list = &quot;mat&quot;)</code></pre>
<pre class="r"><code>library(animation)
ani.options(autobrowse = FALSE)
gif_name = &quot;bad_dimension.gif&quot;
if (!file.exists(gif_name)) {
  arr = as.array(moco_img)
  pdim = pixdim(moco_img)
  saveGIF({
    for (i in seq(bad_ind - 1, bad_ind + 1)) {
      ortho2(arr[,,,i], pdim = pdim, text = i)
    }
  }, movie.name = gif_name)
}</code></pre>
<div class="figure">
<img src="bad_dimension.gif" />

</div>
<p>Much of the rest of the commands are again within R or already implemented in <code>ANTSR</code>. Analyses in FSL commonly use independent components analysis (ICA) with the <code>melodic</code> command. We will not cover that here and will cover it in a subsequent tutorial.</p>
</div>
</div>
</div>
<div id="session-info" class="section level1">
<h1>Session Info</h1>
<pre class="r"><code>devtools::session_info()</code></pre>
<pre><code>Session info -------------------------------------------------------------</code></pre>
<pre><code> setting  value                       
 version  R version 3.3.1 (2016-06-21)
 system   x86_64, darwin13.4.0        
 ui       X11                         
 language (EN)                        
 collate  en_US.UTF-8                 
 tz       America/New_York            
 date     2016-12-21                  </code></pre>
<pre><code>Packages -----------------------------------------------------------------</code></pre>
<pre><code> package     * version     date       source                             
 abind         1.4-5       2016-07-21 cran (@1.4-5)                      
 ANTsR         0.3.3       2016-11-17 Github (stnava/ANTsR@063700b)      
 assertthat    0.1         2013-12-06 CRAN (R 3.2.0)                     
 backports     1.0.4       2016-10-24 CRAN (R 3.3.0)                     
 bitops        1.0-6       2013-08-17 CRAN (R 3.2.0)                     
 colorout    * 1.1-0       2015-04-20 Github (jalvesaq/colorout@1539f1f) 
 devtools      1.12.0.9000 2016-12-08 Github (hadley/devtools@1ce84b0)   
 digest        0.6.10      2016-08-02 cran (@0.6.10)                     
 evaluate      0.10        2016-10-11 CRAN (R 3.3.0)                     
 extrantsr   * 2.8         2016-11-20 local                              
 fslr        * 2.5.1       2016-12-21 Github (muschellij2/fslr@5e46b66)  
 hash          2.2.6       2013-02-21 CRAN (R 3.2.0)                     
 htmltools     0.3.6       2016-12-08 Github (rstudio/htmltools@4fbf990) 
 igraph        1.0.1       2015-06-26 CRAN (R 3.2.0)                     
 iterators     1.0.8       2015-10-13 CRAN (R 3.2.0)                     
 knitr         1.15.1      2016-11-22 cran (@1.15.1)                     
 lattice       0.20-34     2016-09-06 CRAN (R 3.3.0)                     
 magrittr      1.5         2014-11-22 CRAN (R 3.2.0)                     
 Matrix        1.2-7.1     2016-09-01 CRAN (R 3.3.0)                     
 matrixStats   0.51.0      2016-10-09 cran (@0.51.0)                     
 memoise       1.0.0       2016-01-29 CRAN (R 3.2.3)                     
 mgcv          1.8-16      2016-11-07 CRAN (R 3.3.0)                     
 mmap          0.6-12      2013-08-28 CRAN (R 3.3.0)                     
 neurobase   * 1.9.1       2016-12-21 local                              
 neuroim       0.1.0       2016-09-27 local                              
 nlme          3.1-128     2016-05-10 CRAN (R 3.3.1)                     
 oro.nifti   * 0.7.2       2016-12-21 Github (bjw34032/oro.nifti@a713047)
 pkgbuild      0.0.0.9000  2016-12-08 Github (r-pkgs/pkgbuild@65eace0)   
 pkgload       0.0.0.9000  2016-12-08 Github (r-pkgs/pkgload@def2b10)    
 plyr          1.8.4       2016-06-08 CRAN (R 3.3.0)                     
 R.matlab      3.6.1       2016-10-20 CRAN (R 3.3.0)                     
 R.methodsS3   1.7.1       2016-02-16 CRAN (R 3.2.3)                     
 R.oo          1.21.0      2016-11-01 cran (@1.21.0)                     
 R.utils       2.5.0       2016-11-07 cran (@2.5.0)                      
 Rcpp          0.12.8.2    2016-12-08 Github (RcppCore/Rcpp@8c7246e)     
 rmarkdown     1.2.9000    2016-12-08 Github (rstudio/rmarkdown@7a3df75) 
 RNifti        0.3.0       2016-12-08 cran (@0.3.0)                      
 rprojroot     1.1         2016-10-29 cran (@1.1)                        
 stringi       1.1.2       2016-10-01 CRAN (R 3.3.0)                     
 stringr       1.1.0       2016-08-19 cran (@1.1.0)                      
 WhiteStripe   2.0.1       2016-12-02 local                              
 withr         1.0.2       2016-06-20 CRAN (R 3.3.0)                     
 yaImpute      1.0-26      2015-07-20 CRAN (R 3.2.0)                     
 yaml          2.1.14      2016-11-12 CRAN (R 3.3.2)                     </code></pre>
</div>
<div id="references" class="section level1">
<h1>References</h1>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
