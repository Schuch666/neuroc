<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>







</head>

<body>







<p>All code for this document is located at <a href="https://raw.githubusercontent.com/muschellij2/neuroc/master/nifti_basics/index.R">here</a>.</p>
<div id="the-nifti-object" class="section level1">
<h1>The nifti object</h1>
<p>Note: Throughout this post, I will refer to an image on hard disk as a NIfTI, which is a file that generally has the extension “.nii” or “.nii.gz”. I will refer to the object in R as a <code>nifti</code> (note the change of font and case).</p>
<p>In this tutorial we will discuss the basics of the <code>nifti</code> object in R. There are many objects in R that represent imaging data. The Neuroconductor project chose the <code>nifti</code> object from the <code>oro.nifti</code> package as one of the the basic building blocks because it has been widely used in other packages, has been tested over a period of time, and inherits the properties of an <code>array</code> in R.</p>
<p>To run this code, you must have <code>oro.nifti</code> installed. You can either use the stable version on CRAN (using <code>install.packages</code>) or the development version (using <code>devtools::install_github</code>):</p>
<pre class="r"><code>packages = installed.packages()
packages = packages[, &quot;Package&quot;]
if (!&quot;oro.nifti&quot; %in% packages) {
  install.packages(&quot;oro.nifti&quot;)
  ### development version
  # devtools::install_github(&quot;bjw34032/oro.nifti&quot;)
}</code></pre>
<div id="s4-implementation" class="section level2">
<h2>S4 Implementation</h2>
<p>As <code>nifti</code> objects inherits the properties of an <code>array</code>, you can perform a series of operations on them, such as addition/subtraction/division, as you would an <code>array</code>. A <code>nifti</code> object has additional attributes and the <code>nifti</code> object is an S4 object. This means that you do not reference additional information using the <code>$</code> operator.</p>
<pre class="r"><code>library(oro.nifti)
set.seed(20161007)
dims = rep(10, 3)
arr = array(rnorm(10*10*10), dim = dims)
nim = oro.nifti::nifti(arr)
print(nim)</code></pre>
<pre><code>NIfTI-1 format
  Type            : nifti
  Data Type       : 2 (UINT8)
  Bits per Pixel  : 8
  Slice Code      : 0 (Unknown)
  Intent Code     : 0 (None)
  Qform Code      : 0 (Unknown)
  Sform Code      : 0 (Unknown)
  Dimension       : 10 x 10 x 10
  Pixel Dimension : 1 x 1 x 1
  Voxel Units     : Unknown
  Time Units      : Unknown</code></pre>
<pre class="r"><code>print(class(nim))</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
<pre class="r"><code>oro.nifti::is.nifti(nim)</code></pre>
<pre><code>[1] TRUE</code></pre>
<div id="accessing-information-from-a-nifti" class="section level3">
<h3>Accessing Information from a <code>nifti</code></h3>
<p>To access additional information, called a slot, you can use the <code>@</code> operator. We do not recommend this, as there should be a function implemented to “access” this slot. These are hence called accessor functions (they access things!). For example, if you want to get the <code>cal_max</code> slot of a <code>nifti</code> object, you should use the <code>cal_max</code> function. If an accessor function is not implemented, you should still use the <code>slot(object, name)</code> syntax over <code>@</code>.</p>
<p>Here’s an example where we make an array of random normal data, and put that array into a <code>nifti</code> object with the <code>nifti</code> function:</p>
<pre class="r"><code>nim@cal_max</code></pre>
<pre><code>[1] 2.706524</code></pre>
<pre class="r"><code>cal_max(nim)</code></pre>
<pre><code>[1] 2.706524</code></pre>
<pre class="r"><code>slot(nim, &quot;cal_max&quot;)</code></pre>
<pre><code>[1] 2.706524</code></pre>
</div>
<div id="accessing-the-data" class="section level3">
<h3>Accessing the “data”</h3>
<p>If you want to access the “data” of the image, you can access that using:</p>
<pre class="r"><code>data = slot(nim, &quot;.Data&quot;)
class(data)</code></pre>
<pre><code>[1] &quot;array&quot;</code></pre>
<p>With newer versions of <code>oro.nifti</code> (especially that on GitHub and in Neuroconductor), there is a <code>img_data</code> function to access the data:</p>
<pre class="r"><code>data = oro.nifti::img_data(nim)
class(data)</code></pre>
<pre><code>[1] &quot;array&quot;</code></pre>
<pre class="r"><code>dim(data)</code></pre>
<pre><code>[1] 10 10 10</code></pre>
<p>This <code>array</code> is 3-dimensional and can be subset using normal square-bracket notations (<code>[row, column, slice]</code>). Thus, if we want the 3rd “slice” of the image, we can use:</p>
<pre class="r"><code>slice = data[,,3]
class(slice)</code></pre>
<pre><code>[1] &quot;matrix&quot;</code></pre>
<p>Thus we see we get a matrix of values from the 3rd “slice”. We should note that we generally reference an image by x, y, and z planes (in that order). Most of the time, the x direction refers to going left/right on an image, y refers to front/back (or anterior/posterior), and the z direction refers to up/down (superior/inferior). The actual direction depends on the header information of the NIfTI image.</p>
<pre class="r"><code>slice = data[,,3, drop = FALSE]
class(slice)</code></pre>
<pre><code>[1] &quot;array&quot;</code></pre>
</div>
<div id="show-all-slots" class="section level3">
<h3>Show all slots</h3>
<p>You can see which slots exist for a <code>nifti</code> object by using <code>slotNames</code></p>
<pre class="r"><code>slotNames(nim)</code></pre>
<pre><code> [1] &quot;.Data&quot;          &quot;sizeof_hdr&quot;     &quot;data_type&quot;      &quot;db_name&quot;       
 [5] &quot;extents&quot;        &quot;session_error&quot;  &quot;regular&quot;        &quot;dim_info&quot;      
 [9] &quot;dim_&quot;           &quot;intent_p1&quot;      &quot;intent_p2&quot;      &quot;intent_p3&quot;     
[13] &quot;intent_code&quot;    &quot;datatype&quot;       &quot;bitpix&quot;         &quot;slice_start&quot;   
[17] &quot;pixdim&quot;         &quot;vox_offset&quot;     &quot;scl_slope&quot;      &quot;scl_inter&quot;     
[21] &quot;slice_end&quot;      &quot;slice_code&quot;     &quot;xyzt_units&quot;     &quot;cal_max&quot;       
[25] &quot;cal_min&quot;        &quot;slice_duration&quot; &quot;toffset&quot;        &quot;glmax&quot;         
[29] &quot;glmin&quot;          &quot;descrip&quot;        &quot;aux_file&quot;       &quot;qform_code&quot;    
[33] &quot;sform_code&quot;     &quot;quatern_b&quot;      &quot;quatern_c&quot;      &quot;quatern_d&quot;     
[37] &quot;qoffset_x&quot;      &quot;qoffset_y&quot;      &quot;qoffset_z&quot;      &quot;srow_x&quot;        
[41] &quot;srow_y&quot;         &quot;srow_z&quot;         &quot;intent_name&quot;    &quot;magic&quot;         
[45] &quot;extender&quot;       &quot;reoriented&quot;    </code></pre>
<p>If you would like to see information about each one of these slots, please see <a href="https://brainder.org/2012/09/23/the-nifti-file-format/">this blog post</a> about the NIfTI header.</p>
</div>
</div>
</div>
<div id="other-objects" class="section level1">
<h1>Other objects</h1>
<p>Other packages, such as <code>ANTsR</code> and <code>RNifti</code> have implemented faster reading/writing functions of NIfTI images. These rely on pointers to object in memory and are very useful. They have specific implementations for extracting information from them and saving them out, such as in an Rda/rda (R data file). A series of conversion tools for <code>ANTsR</code> objects are included in the <code>extrantsr</code> package (function <code>ants2oro</code>) and <code>nii2oro</code> in <code>oro.nifti</code> for RNifti objects.</p>
</div>
<div id="nifti-inputoutput-readniiwritenii-vs.-readniftiwritenifti" class="section level1">
<h1>NIfTI Input/Output: <code>readnii</code>/<code>writenii</code> vs. <code>readNIfTI</code>/<code>writeNIfTI</code></h1>
<p>In the <code>neurobase</code> package, we provide wrapper functions <code>readnii</code>/<code>writenii</code>, which wrap the <code>oro.nifti</code> functions <code>readNIfTI</code>/<code>writeNIfTI</code>. There are a few reasons for this:</p>
<ol style="list-style-type: decimal">
<li>You can pass a filename with a “.nii.gz” extension to <code>writenii</code> and an additional “.nii.gz” will not be added, whereas this will happen in <code>writeNIfTI</code>.</li>
<li><code>writenii</code> will try to discern the data type of the image before writing, which may be useful if you created a <code>nifti</code> by copying information from a previous <code>nifti</code> object.</li>
<li>The default in <code>readnii</code> is <code>reorient = FALSE</code>, which generally does not error when reading in data, whereas <code>readNIfTI</code> defaults to <code>reorient = TRUE</code>. This is discussed below.</li>
<li>Extraneous dimensions are automatically deleted with <code>readnii</code>. Note this may cause errors and is <strong>not desired 100% of the time</strong>.</li>
</ol>
<div id="option-reorient-false" class="section level2">
<h2>Option <code>reorient = FALSE</code></h2>
<p>In <code>readNIfTI</code> default <code>reorient = TRUE</code> implicity uses the <code>reorient</code> function from <code>oro.nifti</code>. Although many neuroimaging software suites read the header and reorient the data based on that information, <code>oro.nifti::reorient</code> can only handle simple orientations, see <code>oro.nifti::performPermutation</code> documentation. Although reading the data in without reorienting can cause problems, such as not knowing right/left orientation, if multiple NIfTI files were created in the same way (assumingly from <code>dcm2nii</code>), they should ideally have the same orientation.</p>
<p>Derived data from an image will have the exact same orientation because derived <code>nifti</code> objects will copy the <code>nifti</code> header information from the <code>nifti</code> object it was derived from. Moreover, in many analyses, registration to an image or a template is common, and these have known orientations. We have found that if a user wants to reorient their data in R, using the <code>reorient</code> function can be used, but we prefer the default to be <code>FALSE</code>, otherwise reading in many NIfTI files result in an error from the orientation.</p>
</div>
</div>
<div id="operations-of-nifti-objects" class="section level1">
<h1>Operations of <code>nifti</code> objects</h1>
<p>Although the <code>nifti</code> object is not a standard R object, you can perform standard operations on these objects, such as addition/subtraction and logic. This is referred to “overloaded” operators.</p>
<div id="logical-operators" class="section level2">
<h2>Logical operators</h2>
<p>For example, if we want to create a <code>nifti</code> object with binary values, where the values are <code>TRUE</code> if the values in <code>nim</code> are greater than 0, we can simply write:</p>
<pre class="r"><code>above_zero = nim &gt; 0
class(above_zero)</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
<pre class="r"><code>img_data(above_zero)[1]</code></pre>
<pre><code>[1] TRUE</code></pre>
<p>We will refer to binary images/<code>nifti</code> objects as “masks”.</p>
<p>We can combine multiple operators, such as creating a binary mask for value greater than 0 and less than 2.</p>
<pre class="r"><code>class(nim &gt; 0 &amp; nim &lt; 2)</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
</div>
<div id="arithmetic-on-nifti-objects" class="section level2">
<h2>Arithmetic on <code>nifti</code> objects</h2>
<p>We can also show the</p>
<pre class="r"><code>class(nim * 2)</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
<pre class="r"><code>class(nim + (nim / 4))</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
<pre class="r"><code>class(nim * nim)</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
<pre class="r"><code>class(nim^2)</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
</div>
<div id="summaries" class="section level2">
<h2>Summaries</h2>
<p>How many values actually are greater than zero? Here, we can use standard statistical functions, such as <code>sum</code> to count the number of <code>TRUE</code> indices:</p>
<pre class="r"><code>sum(above_zero)</code></pre>
<pre><code>[1] 513</code></pre>
<p>and similarly find the proportion of <code>TRUE</code> indices by taking the <code>mean</code> of these indicators:</p>
<pre class="r"><code>mean(above_zero)</code></pre>
<pre><code>[1] 0.513</code></pre>
<p>Again, as <code>nifti</code> is an S4 object, it should have the functionality described in the details of the help file for <code>methods::S4groupGeneric</code>:</p>
<pre class="r"><code>min(nim)</code></pre>
<pre><code>[1] -3.517075</code></pre>
<pre class="r"><code>max(nim)</code></pre>
<pre><code>[1] 2.706524</code></pre>
<pre class="r"><code>range(nim)</code></pre>
<pre><code>[1] -3.517075  2.706524</code></pre>
<pre class="r"><code>class(abs(nim))</code></pre>
<pre><code>[1] &quot;nifti&quot;
attr(,&quot;package&quot;)
[1] &quot;oro.nifti&quot;</code></pre>
</div>
</div>
<div id="visualization-of-nifti-objects" class="section level1">
<h1>Visualization of <code>nifti</code> objects</h1>
<p>Here we will use real imaging data from the <code>EveTemplate</code> package:</p>
<pre class="r"><code>library(EveTemplate)
eve = readEve(what = &quot;Brain&quot;)</code></pre>
<div id="orthographic-view" class="section level2">
<h2>Orthographic view</h2>
<p>The <code>oro.nifti::orthographic</code> function provides great functionality on displaying <code>nifti</code> objects in 3 different planes.</p>
<pre class="r"><code>oro.nifti::orthographic(eve)</code></pre>
<p><img src="index_files/figure-html/ortho-1.png" /><!-- --></p>
<p>The <code>neurobase::ortho2</code> function expands upon this with some different defaults.</p>
<pre class="r"><code>neurobase::ortho2(eve)</code></pre>
<p><img src="index_files/figure-html/ortho2-1.png" /><!-- --></p>
<p>We see that in <code>ortho2</code> there are annotations of the orientation of the image. Again, if the image was not reoriented, then these many not be corrrect. You can turn these off with the <code>add.orient</code> argument:</p>
<pre class="r"><code>neurobase::ortho2(eve, add.orient = FALSE)</code></pre>
<p><img src="index_files/figure-html/ortho2_noorient-1.png" /><!-- --></p>
<div id="differences-between-orthographic-and-ortho2" class="section level3">
<h3>Differences between <code>orthographic</code> and <code>ortho2</code></h3>
<p>The above code does not fully illustrate the differences between <code>orthographic</code> and <code>ortho2</code>. One marked difference is when you would like to “overlay” an image on top of another in an orthograhic view. Here we will highlight voxels greater than the 90th quantile of the image:</p>
<pre class="r"><code>orthographic(eve, y = eve &gt; quantile(eve, 0.9))</code></pre>
<p><img src="index_files/figure-html/ortho_nona-1.png" /><!-- --></p>
<p>We see that the white matter is represented here, but we would like to see areas of the brain that are not over this quantile to be shown as the image. Let us contrast this with:</p>
<pre class="r"><code>ortho2(eve, y = eve &gt; quantile(eve, 0.9))</code></pre>
<p><img src="index_files/figure-html/ortho2_nona-1.png" /><!-- --></p>
<p>We see the image where the mask is 0 shows the original image. This is due to the <code>NA.y</code> argument in <code>ortho2</code>. The <code>ortho2</code> (and <code>orthograhic</code>) function is based on the <code>graphics::image</code> function in R, as well as many other functions we will discuss below. When <code>graphics::image</code> sees an <code>NA</code> value, it does not plot anything there. The <code>NA.y</code> argument in <code>ortho2</code> makes it so any values in the <code>y</code> argument (in this case the mask) that are equal to zero are turned to <code>NA</code>.</p>
</div>
<div id="bright-values" class="section level3">
<h3>Bright values</h3>
<p>If you have artifacts or simply large values of an image, it can “dampen” the viewing of an image. Let’s make one value of the eve template very large. We will set the voxel with the largest value to be that value times 5 :</p>
<pre class="r"><code>eve2 = eve
eve2[which.max(eve)] = eve2[which.max(eve)] * 5</code></pre>
<p>Let’s plot this image again:</p>
<pre class="r"><code>ortho2(eve2)</code></pre>
<p><img src="index_files/figure-html/ortho2_large-1.png" /><!-- --></p>
<p>We see a faint outline of the image, but this single large value affects how we view the image. The function <code>robust_window</code> calculates quantiles of an image, by default the 0 (min) and 99.9th quantile, and sets values outside of this range to that quantile. If you are familiar with the process of <a href="https://en.wikipedia.org/wiki/Winsorizing">Winsorizing</a>, this is the exact same procedure. Many times we use this function to plotting, but could be thought of an outlier dampening procedure. Let’s plot this windowed image:</p>
<pre class="r"><code>ortho2(robust_window(eve2))</code></pre>
<p><img src="index_files/figure-html/ortho2_rob-1.png" /><!-- --></p>
<p>Changing the <code>probs</code> argument in <code>robust_window</code>, which is passed to <code>quantile</code>, can also be used to limit artifacts with remarkably low values. The <code>zlim</code> option can also denote which range of intensities that can be plotted:</p>
<pre class="r"><code>ortho2(eve2, zlim = quantile(eve2, probs = c(0, 0.999)))</code></pre>
<p><img src="index_files/figure-html/ortho2_zlim-1.png" /><!-- --></p>
<p>This is a bit more like trimming, however.</p>
</div>
<div id="double-orthographic-view" class="section level3">
<h3>Double orthographic view</h3>
<p>Sometimes you would like to represent 2 images side by side, of the same dimensions and orientation of course. The <code>double_ortho</code> function allows you to do this. Let’s read in the full Eve image, not just the brain</p>
<pre class="r"><code>eve_full = readEve(what = &quot;T1&quot;)</code></pre>
<p>We can view the original T1 alongside the brain-extracted image:</p>
<pre class="r"><code>double_ortho(eve_full, eve)</code></pre>
<p><img src="index_files/figure-html/double_ortho-1.png" /><!-- --></p>
</div>
</div>
<div id="single-slice-view" class="section level2">
<h2>Single slice view</h2>
<p>We may want to view a single slice of an image. The <code>oro.nifti::image</code> function can be used here. Note, <code>graphics::image</code> exists and <code>oro.nifti::image</code> both exist. The <code>oro.nifti::image</code> allows you to just write <code>image(nifti_object)</code>, which performs operations and calls functions using <code>graphics::image</code>. This allows the user to use a “generic” version of <code>image</code>, which <code>oro.nifti</code> adapted specifically for <code>nifti</code> objects. You can see the help for this function in <code>?image.nifti</code>.</p>
<p>Let’s plot an image of the 90th slice of <code>eve</code></p>
<pre class="r"><code>image(eve, z = 90)</code></pre>
<p><img src="index_files/figure-html/all_slices-1.png" /><!-- --></p>
<p>What happened? Well, the default argument <code>plot.type</code> in <code>image.nifti</code> is set for <code>&quot;multiple&quot;</code>, so that even if you specify a slice, it will plot <strong>all</strong> slices. Here, if we pass <code>plot.type = &quot;single&quot;</code>, we get the single slice we want.</p>
<pre class="r"><code>image(eve, z = 90, plot.type = &quot;single&quot;)</code></pre>
<p><img src="index_files/figure-html/one_slice-1.png" /><!-- --></p>
<p>If we put multiple slices with <code>plot.type = &quot;single&quot;</code>, then we will get a view of these 2 slices.</p>
<pre class="r"><code>image(eve, z = c(90, 100), plot.type = &quot;single&quot;)</code></pre>
<p><img src="index_files/figure-html/two_slice-1.png" /><!-- --></p>
<div id="different-planes" class="section level3">
<h3>Different Planes</h3>
<p>We can specify <code>z</code> the same way but change the <code>plane</code> to be different to get a different slice of the brain:</p>
<pre class="r"><code>image(eve, z = 98, plot.type = &quot;single&quot;, plane = &quot;sagittal&quot;)</code></pre>
<p><img src="index_files/figure-html/one_slice_sag-1.png" /><!-- --> We can similarly do the same for “coronal” slices.</p>
</div>
</div>
<div id="overlaying-slices" class="section level2">
<h2>Overlaying slices</h2>
<p>We can also overlay one slice of an image upon another using the <code>oro.nifti::overlay</code> function. Here we must specify <code>plot.type</code> again for only one slice.</p>
<pre class="r"><code>overlay(eve, y = eve &gt; quantile(eve, 0.9), z = 90, plot.type = &quot;single&quot;)</code></pre>
<p><img src="index_files/figure-html/one_slice_overlay-1.png" /><!-- --></p>
<p>We have not yet implemented <code>overlay2</code> (at the time of running this), which has the <code>NA.y</code> option, but will in the future. We can do this prior to plotting and pass in this <code>NA</code>’d mask:</p>
<pre class="r"><code>mask = eve &gt; quantile(eve, 0.9)
mask[ mask == 0] = NA
overlay(eve, y = mask, z = 90, plot.type = &quot;single&quot;)</code></pre>
<p><img src="index_files/figure-html/one_slice_overlay_right-1.png" /><!-- --></p>
<pre class="r"><code>rm(list = &quot;mask&quot;)</code></pre>
</div>
<div id="dropping-empty-dimensions" class="section level2">
<h2>Dropping empty dimensions</h2>
<p>In some instances, there are extraneous slices to an image. For example, in the Eve template image we read in, it is just the brain. Areas of the skull and extracranial tissue are removed, but the slices remain so that the brain image and the original image are in the same space with the same dimensions. For plotting or further analyses, we can drop these empty dimensions using the <code>neurobase::dropEmptyImageDimensions</code> function or <code>drop_empty_dim</code> shorthand function.<br />
By default, if one <code>nifti</code> is passed to the function and <code>keep_ind = FALSE</code>, then the return is a <code>nifti</code> object.</p>
<pre class="r"><code>reduced = dropEmptyImageDimensions(eve)
dim(eve)</code></pre>
<pre><code>[1] 181 217 181</code></pre>
<pre class="r"><code>dim(reduced)</code></pre>
<pre><code>[1] 148 182 152</code></pre>
<p>We can now plot the reduced image:</p>
<pre class="r"><code>ortho2(reduced)</code></pre>
<p><img src="index_files/figure-html/plot_red-1.png" /><!-- --></p>
<p>which we can contrast with the plotting the full image</p>
<pre class="r"><code>ortho2(eve)</code></pre>
<p><img src="index_files/figure-html/plot_full_eve-1.png" /><!-- --></p>
<div id="dropping-with-multiple-images" class="section level3">
<h3>Dropping with multiple images</h3>
<p>You can pass in other images in the <code>other.imgs</code> function to applying this dropping procedure. For example, let’s say you have 3 images, a T1, T2, and FLAIR image that are all registered to the T1 image and have a brain mask from the T1 image. You can pass in the mask image and pass in the other images into <code>other.imgs</code> so they all drop the same slices and are the same dimensions after the procedure (as they were the same prior), whereas if you performed the operation you may not be ensured to drop exactly the same slices due to some modalities allowing values of zero (albeit highly unlikely).</p>
</div>
<div id="adding-back-the-dropped-dimensions" class="section level3">
<h3>Adding back the dropped dimensions</h3>
<p>To reverse this procedure, the <code>replace_dropped_dimensions</code> function will add back dimensions to the image correctly using the indices from <code>drop_empty_dim</code>. Here is an example:</p>
<pre class="r"><code>dd = dropEmptyImageDimensions(eve, keep_ind = TRUE)
reduced = dd$outimg
reversed = replace_dropped_dimensions(img = reduced, 
                                      inds = dd$inds,
                                      orig.dim = dd$orig.dim)
all(reversed == eve)</code></pre>
<pre><code>[1] TRUE</code></pre>
</div>
</div>
</div>
<div id="manipulating-nifti-images" class="section level1">
<h1>Manipulating <code>nifti</code> images</h1>
<div id="creating-copies-of-nifti" class="section level2">
<h2>Creating copies of <code>nifti</code></h2>
<p>Sometimes you want to create a copy of a <code>nifti</code> object. Many times performing an operation will create this output for you. Other times, you may want a shell <code>nifti</code> object.</p>
<div id="copying-header-information" class="section level3">
<h3>Copying header information</h3>
<p>If you have an array, you can simply write:</p>
<pre class="r"><code>dims = dim(eve)
arr = array(rnorm(prod(dims)), dim = dims)
nim = nifti(arr)
nim</code></pre>
<pre><code>NIfTI-1 format
  Type            : nifti
  Data Type       : 2 (UINT8)
  Bits per Pixel  : 8
  Slice Code      : 0 (Unknown)
  Intent Code     : 0 (None)
  Qform Code      : 0 (Unknown)
  Sform Code      : 0 (Unknown)
  Dimension       : 181 x 217 x 181
  Pixel Dimension : 1 x 1 x 1
  Voxel Units     : Unknown
  Time Units      : Unknown</code></pre>
<p>but the header information of the <code>nifti</code> output <code>nim</code> does not match that of <code>eve</code>. The <code>copyNIfTIHeader</code> function allows you to…copy the NIfTI header:</p>
<pre class="r"><code>nim = copyNIfTIHeader(img = eve, arr = nim)
nim</code></pre>
<pre><code>NIfTI-1 format
  Type            : nifti
  Data Type       : 16 (FLOAT32)
  Bits per Pixel  : 32
  Slice Code      : 0 (Unknown)
  Intent Code     : 0 (None)
  Qform Code      : 2 (Aligned_Anat)
  Sform Code      : 1 (Scanner_Anat)
  Dimension       : 181 x 217 x 181
  Pixel Dimension : 1 x 1 x 1
  Voxel Units     : mm
  Time Units      : Unknown</code></pre>
</div>
<div id="creating-a-shell" class="section level3">
<h3>Creating a “shell”</h3>
<p>The <code>niftiarr</code> function does much of the same functionality of <code>copyNIfTIHeader</code>, but <code>copyNIfTIHeader</code> you have an <code>array</code> or <code>nifti</code> in the <code>arr</code> argument. If you wanted a <code>nifti</code> object with the same header as <code>eve</code>, but all zeroes, you can use <code>niftiarr</code>:</p>
<pre class="r"><code>zeroes = niftiarr(eve, 0)</code></pre>
<p>The main difference is the line in <code>niftiarr</code>:</p>
<pre class="r"><code>if (!is(arr, &quot;array&quot;)){
  arr = array(arr, dim=dim(img))
}</code></pre>
<p>which implies that if you pass in a <code>vector</code> instead of an <code>array</code>, it will create an <code>array</code> on the fly. Sometimes you want an operation to error if <code>arr</code> is not an <code>array</code> (as in <code>copyNIfTIHeader</code>) or be able to pass in a vector and get the correct output <code>niftiarr</code>.</p>
<p>Technical note: This code is legacy and somewhat old and probably can (and may be) replaced by making <code>copyNIfTIHeader</code> a generic and having different versions for when <code>arr</code> is an <code>array</code> or <code>vector</code>.</p>
</div>
</div>
<div id="masking" class="section level2">
<h2>Masking</h2>
<p>Many times you mask an image based on a binary mask. This means any values where the mask is 1, the values will remain, and if the mask is zero or <code>NA</code>, they will be changed (to either zero or <code>NA</code>).</p>
<p>The operation of masking is simply multiplication, multiplying an array by a binary (with or without <code>NA</code>s). Although this is simple, we have created the <code>mask_img</code> function to perform some checking on the <code>mask</code>, such as are all values 0/1. It also has the argument <code>allow.NA</code>, which denotes whether <code>NA</code>s should be allowed or not in the mask.</p>
<p>Here we will simply mask out values of <code>eve</code> that are less than the mean:</p>
<pre class="r"><code>eve_masked = mask_img(eve, eve &gt; mean(eve))</code></pre>
<pre class="r"><code>ortho2(eve_masked)</code></pre>
<p><img src="index_files/figure-html/plot_mask-1.png" /><!-- --></p>
</div>
<div id="vectorizing-a-nifti" class="section level2">
<h2>Vectorizing a <code>nifti</code></h2>
<p>To convert a <code>nifti</code> to a <code>vector</code>, you can simply use the <code>c()</code> operator:</p>
<pre class="r"><code>vals = c(eve)
class(vals)</code></pre>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<p>Note an <code>array</code> can be reconstructed by using <code>array(vals, dim = dim(eve))</code> and will be in the correct order as the way R creates vectors and arrays.</p>
<p>From these values we can do all the standard plotting/manipulations of data. For example, let’s do a marginal density of the values:</p>
<pre class="r"><code>plot(density(vals))</code></pre>
<p><img src="index_files/figure-html/dens-1.png" /><!-- --></p>
<p>This plot is good, but it’s over all voxels in the image, which are mostly zero due to the background. Therefore we see a large spike at zero, but not much information of the distribution of values within the mask. We need to subset the values by the mask.</p>
<div id="subsetting-via-masks" class="section level3">
<h3>Subsetting via masks</h3>
<p>In a previous example, we calculated the mean of <code>eve</code> over the entire image. Many times we want to calculate values over a mask. For example, let’s get the mean of all voxels in the mask, where the mask is any value of <code>eve</code> greater than zero. We can do this by subsetting the values in the mask and then calculating the mean:</p>
<pre class="r"><code>vals = eve[ eve &gt; 0 ]
mean(vals)</code></pre>
<pre><code>[1] 224.1273</code></pre>
<pre class="r"><code>mean(eve)</code></pre>
<pre><code>[1] 58.11317</code></pre>
<p>We see that the mean of the voxels in the mask versus all voxels is very different, because the voxels not in the mask are simply adding zeroes to the calculation. We could simply do the same by making zero voxels <code>NA</code> and adding the <code>na.rm</code> argument to <code>TRUE</code> for the mean.</p>
<pre class="r"><code>mask = eve &gt; 0
mask[ mask == 0 ] = NA
eve_masked = mask_img(eve, mask)
mean(eve_masked)</code></pre>
<pre><code>[1] NA</code></pre>
<pre class="r"><code>mean(eve_masked, na.rm = TRUE)</code></pre>
<pre><code>[1] 224.1273</code></pre>
<p>Again, as <code>nifti</code> objects inherits properties from <code>array</code> objects, we can subset using logical indices, as above in <code>mask == 0</code> and could use indices such as <code>which(mask == 0)</code>.</p>
<p>We can do a marginal density of the values only in the mask:</p>
<pre class="r"><code>vals = eve[ eve &gt; 0 ]</code></pre>
<pre class="r"><code>plot(density(vals))</code></pre>
<p><img src="index_files/figure-html/dens_2-1.png" /><!-- --></p>
</div>
</div>
<div id="creating-data.frames" class="section level2">
<h2>Creating <code>data.frame</code>s</h2>
<p>In many cases, we may have multiple images in the same space. We can simply create a <code>data.frame</code> by vectorizing each image. Here we will read in the T2 image, which is the same space as the T1.</p>
<pre class="r"><code>t2 = readEve(what = &quot;T2&quot;)
df = data.frame(T1 = c(eve_full),
                T2 = c(t2),
                mask = c(eve &gt; 0))
head(df)</code></pre>
<pre><code>  T1 T2  mask
1  0  0 FALSE
2  0  0 FALSE
3  0  0 FALSE
4  0  0 FALSE
5  0  0 FALSE
6  0  0 FALSE</code></pre>
<p>We can then perform standard operations on the <code>data.frame</code> as we would any other <code>data.frame</code>. Let’s keep only voxels in the <code>mask</code>, then remove the column of the <code>mask</code>.</p>
<pre class="r"><code>library(dplyr)</code></pre>
<pre><code>
Attaching package: &#39;dplyr&#39;</code></pre>
<pre><code>The following objects are masked from &#39;package:stats&#39;:

    filter, lag</code></pre>
<pre><code>The following objects are masked from &#39;package:base&#39;:

    intersect, setdiff, setequal, union</code></pre>
<pre class="r"><code>df = df %&gt;% 
  filter(mask) %&gt;% 
  select(-mask)</code></pre>
<div id="bi-variate-distributions" class="section level3">
<h3>Bi-variate distributions</h3>
<p>Here we make binned hexagrams to represent the 2-dimensional distributions of each imaging sequence against the other.</p>
<pre class="r"><code>library(ggplot2)
g = ggplot(df) + stat_binhex()
g + aes(x = T1, y = T2)</code></pre>
<p><img src="index_files/figure-html/make_hex-1.png" /><!-- --></p>
</div>
<div id="marginal-distributions" class="section level3">
<h3>Marginal distributions</h3>
<p>Here we plot the distributions of the T1 and T2 imaging sequences separately.</p>
<pre class="r"><code>long = reshape2::melt(as.matrix(df))
colnames(long) = c(&quot;ind&quot;, &quot;sequence&quot;, &quot;value&quot;)
long$ind = NULL</code></pre>
<pre class="r"><code>library(ggplot2)
ggplot(long, aes(x = value)) + 
  geom_line(stat = &quot;density&quot;) +
  facet_wrap(~ sequence, 
             scales = &quot;free_x&quot;)</code></pre>
<p><img src="index_files/figure-html/make_dists-1.png" /><!-- --></p>
</div>
</div>
</div>
<div id="session-info" class="section level1">
<h1>Session Info</h1>
<pre class="r"><code>devtools::session_info()</code></pre>
<pre><code>Session info --------------------------------------------------------------</code></pre>
<pre><code> setting  value                       
 version  R version 3.3.1 (2016-06-21)
 system   x86_64, darwin13.4.0        
 ui       X11                         
 language (EN)                        
 collate  en_US.UTF-8                 
 tz       America/New_York            
 date     2016-11-09                  </code></pre>
<pre><code>Packages ------------------------------------------------------------------</code></pre>
<pre><code> package     * version date       source                             
 abind         1.4-5   2016-07-21 cran (@1.4-5)                      
 assertthat    0.1     2013-12-06 CRAN (R 3.2.0)                     
 bitops        1.0-6   2013-08-17 CRAN (R 3.2.0)                     
 codetools     0.2-14  2015-07-15 CRAN (R 3.3.1)                     
 colorout    * 1.1-0   2015-04-20 Github (jalvesaq/colorout@1539f1f) 
 colorspace    1.2-6   2015-03-11 CRAN (R 3.2.0)                     
 DBI           0.5-1   2016-09-10 CRAN (R 3.3.0)                     
 devtools      1.12.0  2016-06-24 CRAN (R 3.3.0)                     
 digest        0.6.10  2016-08-02 cran (@0.6.10)                     
 dplyr       * 0.5.0   2016-06-24 CRAN (R 3.3.0)                     
 evaluate      0.9     2016-04-29 CRAN (R 3.2.5)                     
 EveTemplate * 0.99.14 2016-09-15 local                              
 formatR       1.4     2016-05-09 CRAN (R 3.2.5)                     
 ggplot2     * 2.1.0   2016-03-01 CRAN (R 3.3.0)                     
 gtable        0.2.0   2016-02-26 CRAN (R 3.2.3)                     
 hexbin      * 1.27.1  2015-08-19 CRAN (R 3.2.0)                     
 htmltools     0.3.6   2016-09-26 Github (rstudio/htmltools@6996430) 
 knitr         1.14    2016-08-13 CRAN (R 3.3.0)                     
 labeling      0.3     2014-08-23 CRAN (R 3.2.0)                     
 lattice       0.20-34 2016-09-06 CRAN (R 3.3.0)                     
 lazyeval      0.2.0   2016-06-12 CRAN (R 3.3.0)                     
 magrittr      1.5     2014-11-22 CRAN (R 3.2.0)                     
 matrixStats   0.51.0  2016-10-09 cran (@0.51.0)                     
 memoise       1.0.0   2016-01-29 CRAN (R 3.2.3)                     
 munsell       0.4.3   2016-02-13 CRAN (R 3.2.3)                     
 neurobase   * 1.5.1   2016-11-04 local                              
 oro.nifti   * 0.6.2   2016-11-04 Github (bjw34032/oro.nifti@fe54c8e)
 plyr          1.8.4   2016-06-08 CRAN (R 3.3.0)                     
 R.methodsS3   1.7.1   2016-02-16 CRAN (R 3.2.3)                     
 R.oo          1.20.0  2016-02-17 CRAN (R 3.2.3)                     
 R.utils       2.4.0   2016-09-14 cran (@2.4.0)                      
 R6            2.2.0   2016-10-05 cran (@2.2.0)                      
 Rcpp          0.12.7  2016-09-05 cran (@0.12.7)                     
 reshape2      1.4.1   2014-12-06 CRAN (R 3.2.0)                     
 rmarkdown     1.1     2016-10-16 CRAN (R 3.3.1)                     
 RNifti        0.2.2   2016-10-02 cran (@0.2.2)                      
 scales        0.4.0   2016-02-26 CRAN (R 3.2.3)                     
 stringi       1.1.1   2016-05-27 CRAN (R 3.3.0)                     
 stringr       1.1.0   2016-08-19 cran (@1.1.0)                      
 tibble        1.2     2016-08-26 CRAN (R 3.3.0)                     
 withr         1.0.2   2016-06-20 CRAN (R 3.3.0)                     
 yaml          2.1.13  2014-06-12 CRAN (R 3.2.0)                     </code></pre>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
