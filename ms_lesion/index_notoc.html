<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">



<title></title>

<link href="index_notoc_files/highlightjs-1.1/default.css" rel="stylesheet" />
<script src="index_notoc_files/highlightjs-1.1/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>





</head>

<body>







<p>All code for this document is located at <a href="https://raw.githubusercontent.com/muschellij2/neuroc/master/ms_lesion/index.R">here</a>.</p>
<div id="data" class="section level1">
<h1>Data</h1>
<p>We will be using the data from the <a href="https://github.com/muschellij2/fslr_data">2015 Longitudinal Multiple Sclerosis Lesion Segmentation Challenge</a>. The data consists of a single subject at 2 time points, baseline and followup. The data is available for non-commercial purposes. We will download the data from GitHub using the <code>git2r</code> package.</p>
<div id="data-description" class="section level2">
<h2>Data Description</h2>
<p>The data description was presented in <span class="citation">E. Sweeney et al. (2013)</span>. The data in the folder was also discussed in <span class="citation">Muschelli et al. (2015)</span>. It consists of one patient with multiple sclerosis (MS) with multi-sequence magnetic resonance imaging (MRI) data from 2 different time points.</p>
</div>
<div id="package-version" class="section level2">
<h2>Package Version</h2>
<p>Here we will be using the <code>oasis</code> package greater than version 2.2. If you do not have this package and it’s not located on CRAN yet, we will install it from GitHub.</p>
<pre class="r"><code>library(dplyr)
loaded_package_version = function(pkg) {
  packs = devtools::session_info()$packages
  ver = packs %&gt;% 
    filter(package %in% pkg) %&gt;% 
    select(package, version)
  return(ver)
}
check_package_version = function(pkg, min_version){
  stopifnot(length(pkg) == 1)
  ver = loaded_package_version(pkg = pkg)
  ver = as.character(ver$version)
  min_version = as.character(min_version)
  # check to see if version is at least the min_version
  utils::compareVersion(a = ver, b = min_version) &gt;= 0
}
check = check_package_version(&quot;oasis&quot;, min_version = &quot;2.2&quot;)
if (!check) {
  devtools::install_github(&quot;emsweene/oasis&quot;)
}</code></pre>
<p>There was a slight bug in <code>oasis_preproc</code> which needed to be corrected for the following code to work</p>
<!-- # Converting the data -->
<!-- The data come in `nhdr`/`raw` image pairs, which are part of the [NRRD format](http://teem.sourceforge.net/nrrd/format.html).  The `ANTsR` package can read these in using `antsImageRead` and we cannot read them in as per usual using `readnii` or `readNIfTI`.  We will convert the images to `.nii.gz` files using the `extrantsr::c3d` command that wraps `antsImageRead` and `antsImageWrite`.   -->
<!-- For this example, we will assume you have copied all files into one directory called `data`: -->
<!-- ```{r readers, eval = FALSE} -->
<!-- library(extrantsr) -->
<!-- files = list.files(path = "data", pattern = "[.]nhdr") -->
<!-- sapply(files, function(infile) { -->
<!--   outfile = gsub("[.]nhdr$", ".nii.gz", infile) -->
<!--   c3d(infile, outfile) -->
<!-- }) -->
<!-- ``` -->
<!-- We can them remove any `nhdr`/`raw` pairs. -->
</div>
</div>
<div id="getting-the-data" class="section level1">
<h1>Getting the data</h1>
<p>We will use the <code>git2r</code> package to download the package into a folder called <code>data</code>. The code below will clone the GitHub repository to the <code>data</code> folder, then delete the <code>.git</code> folder, which stores changes to the data, which can be a large file. We will also delete any processed data such as the brain mask and the skull-stripped image.</p>
<pre class="r"><code>library(git2r)
if (!dir.exists(&quot;data&quot;)) {
  repo = clone(url = &quot;https://github.com/muschellij2/fslr_data&quot;,
      local_path = &quot;data/&quot;)
  unlink(file.path(&quot;data/.git&quot;), recursive = TRUE)
  file.remove(file.path(&quot;data&quot;, &quot;SS_Image.nii.gz&quot;))
  file.remove(file.path(&quot;data&quot;, &quot;Brain_Mask.nii.gz&quot;))
}</code></pre>
</div>
<div id="creating-a-filename-data.frame" class="section level1">
<h1>Creating a filename <code>data.frame</code></h1>
<p>Here we will make a <code>data.frame</code> that has the imaging modality and the case number so we can sort or reorder if necessary:</p>
<pre class="r"><code>df = list.files(path = &quot;data&quot;, 
                   pattern = &quot;[.]nii[.]gz$&quot;, 
                   full.names = TRUE)
df = data.frame(file = df, stringsAsFactors = FALSE)
print(head(df))</code></pre>
<pre><code>                                             file
1              data/01-Baseline_Brain_Mask.nii.gz
2 data/01-Baseline_FLAIR_ants_preprocessed.nii.gz
3      data/01-Baseline_FLAIR_preprocessed.nii.gz
4                   data/01-Baseline_FLAIR.nii.gz
5           data/01-Baseline_N4_Brain_Mask.nii.gz
6    data/01-Baseline_PD_ants_preprocessed.nii.gz</code></pre>
<p>We have the filenames in one column and will be doing some string manipulation to parse the information about the id and the modality/sequence:</p>
<pre class="r"><code>df$fname = nii.stub(df$file, bn = TRUE)
df$id = gsub(&quot;^(\\d\\d)-.*&quot;, &quot;\\1&quot;, df$fname)
df$timepoint = gsub(&quot;^\\d\\d-(.*)_.*$&quot;, &quot;\\1&quot;, df$fname)
df$modality = gsub(&quot;\\d\\d-.*_(.*)$&quot;, &quot;\\1&quot;, df$fname)
print(unique(df$id))</code></pre>
<pre><code>[1] &quot;01&quot;</code></pre>
<pre class="r"><code>print(unique(df$modality))</code></pre>
<pre><code>[1] &quot;Mask&quot;         &quot;preprocessed&quot; &quot;FLAIR&quot;        &quot;PD&quot;          
[5] &quot;T1&quot;           &quot;T2&quot;          </code></pre>
<pre class="r"><code>print(head(df))</code></pre>
<pre><code>                                             file
1              data/01-Baseline_Brain_Mask.nii.gz
2 data/01-Baseline_FLAIR_ants_preprocessed.nii.gz
3      data/01-Baseline_FLAIR_preprocessed.nii.gz
4                   data/01-Baseline_FLAIR.nii.gz
5           data/01-Baseline_N4_Brain_Mask.nii.gz
6    data/01-Baseline_PD_ants_preprocessed.nii.gz
                                fname id           timepoint     modality
1              01-Baseline_Brain_Mask 01      Baseline_Brain         Mask
2 01-Baseline_FLAIR_ants_preprocessed 01 Baseline_FLAIR_ants preprocessed
3      01-Baseline_FLAIR_preprocessed 01      Baseline_FLAIR preprocessed
4                   01-Baseline_FLAIR 01            Baseline        FLAIR
5           01-Baseline_N4_Brain_Mask 01   Baseline_N4_Brain         Mask
6    01-Baseline_PD_ants_preprocessed 01    Baseline_PD_ants preprocessed</code></pre>
<!-- ## Multiple segmentation files -->
<!-- Here we see that there are 1 ids and a set of modalities.  We should also note that we have 2 separate lesion segmentations.  Each are from different readers.  We will use the segmentation from reader `1` for this analysis.  There are techniques such as label fusion that will allow you to combine multiple segmentations.  You can also use the voxel-wise mean of the segmentations.  Since there are only 2 segmentations here, however, after thresholding this mean, you are using a rule that says a voxel is a lesion if both agree or if at least one reader indicates that voxel is a lesion.   -->
<!-- Here we will remove the reader 2 segmentation and reorder the `data.frame` based on the ordering of the modalities.  -->
<!-- ```{r removing_chb} -->
<!-- df = df %>%  -->
<!--   filter(modality != "mask2") %>%  -->
<!--   mutate(modality = gsub("mask\\d", "mask", modality)) -->
<!-- df = df %>%  -->
<!--   mutate(modality =  -->
<!--            factor(modality,   -->
<!--                   levels = c("T1", "T2", "FLAIR", "PD", "mask"))) -->
<!-- df = df %>%  -->
<!--   arrange(id, modality) -->
<!-- ``` -->
</div>
<div id="cross-sectional-ms-lesion-segmentation-oasis-package" class="section level1">
<h1>Cross-sectional MS Lesion Segmentation: OASIS package</h1>
<p>The <code>oasis</code> package implements the pipeline from <span class="citation">E. M. Sweeney et al. (2013)</span>. The package relies on <code>fslr</code> and therefore a working installation of FSL. The package will perform the data preprocessing, train a model for lesion segmentation if gold-standard, manual segmentations are provided, and predict lesions from that model or the model from <span class="citation">E. M. Sweeney et al. (2013)</span> if no model (e.g. no gold standard) is provided.</p>
<pre class="r"><code>ss = split(df, df$timepoint)
ss = lapply(ss, function(x){
  mods = x$modality
  xx = x$file
  names(xx) = mods
  return(xx)
})</code></pre>
<div id="preprocessing" class="section level2">
<h2>Preprocessing</h2>
<p>The preprocessing is performed using the <code>oasis_preproc</code> function. It requires a T1, T2, and FLAIR image. A proton density (PD) is not necessary, but the original OASIS model had PD and the model in the package relies on a PD image.</p>
<pre class="r"><code>dat = ss[[1]]
print(dat)</code></pre>
<pre><code>                          FLAIR                              PD 
&quot;data/01-Baseline_FLAIR.nii.gz&quot;    &quot;data/01-Baseline_PD.nii.gz&quot; 
                             T1                              T2 
   &quot;data/01-Baseline_T1.nii.gz&quot;    &quot;data/01-Baseline_T2.nii.gz&quot; </code></pre>
<pre class="r"><code># preparing output filenames
outfiles = nii.stub(dat)
brain_mask = gsub(&quot;_T1$&quot;, &quot;&quot;, outfiles[&quot;T1&quot;])
brain_mask = paste0(brain_mask, &quot;_Brain_Mask.nii.gz&quot;)
outfiles = paste0(outfiles, &quot;_preprocessed.nii.gz&quot;)
names(outfiles) = names(dat)
outfiles = c(outfiles, brain_mask = brain_mask)
outfiles = outfiles[ names(outfiles) != &quot;mask&quot;]

if (!all(file.exists(outfiles))) {
  pre = oasis_preproc(
    flair = dat[&quot;FLAIR&quot;], 
    t1 = dat[&quot;T1&quot;],
    t2 = dat[&quot;T2&quot;],
    pd = dat[&quot;PD&quot;],
    cores = 1)
  
  writenii(pre$t1, filename = outfiles[&quot;T1&quot;])
  writenii(pre$t2, filename = outfiles[&quot;T2&quot;])
  writenii(pre$flair, filename = outfiles[&quot;FLAIR&quot;])
  writenii(pre$pd, filename = outfiles[&quot;PD&quot;])
  writenii(pre$brain_mask, filename  = outfiles[&quot;brain_mask&quot;])
}</code></pre>
</div>
<div id="review-of-the-results" class="section level2">
<h2>Review of the results</h2>
<p>Here we will read in the output images and the brain mask. We will normalize the image intensities using <code>zscore_img</code> so that the intensities are in the same scale range for plotting. We will</p>
<pre class="r"><code>imgs = lapply(outfiles[c(&quot;T1&quot;, &quot;T2&quot;, &quot;FLAIR&quot;, &quot;PD&quot;)], readnii)
brain_mask = readnii(outfiles[&quot;brain_mask&quot;])
imgs = lapply(imgs, robust_window)
norm_imgs = lapply(imgs, zscore_img, margin = NULL, mask = brain_mask)</code></pre>
<p>We will drop the empty image dimensions for plotting later. We pass in the <code>mask</code> and the list of normalized images, remove the empty dimensions, and then we later re-mask the data</p>
<pre class="r"><code>dd = dropEmptyImageDimensions(brain_mask, other.imgs = norm_imgs)
red_mask = dd$outimg
norm_imgs = dd$other.imgs
norm_imgs = lapply(norm_imgs, mask_img, mask = red_mask)</code></pre>
<p>Here we will show each imaging modality at the same slice:</p>
<pre class="r"><code>z = floor(nsli(norm_imgs[[1]])/2)
multi_overlay(
  norm_imgs, 
  z = z, 
  text = names(norm_imgs),
  text.x = 
    rep(0.5, length(norm_imgs)),
  text.y = 
    rep(1.4, length(norm_imgs)), 
  text.cex = 
    rep(2.5, length(norm_imgs)))</code></pre>
<p><img src="index_files/figure-html/overlay_plots-1.png" /><!-- --></p>
<p>We see that the registration seems to have performed well in that the same slice across sequences represent the same areas of the brain.</p>
</div>
<div id="creating-predictors" class="section level2">
<h2>Creating Predictors</h2>
<p>Now that we’ve performed preprocessing of the data, we can create a dataset of these images whole-brain normalized and a series of smoothed images of the data.</p>
<pre class="r"><code>df_list = oasis_train_dataframe(
  flair = outfiles[&quot;FLAIR&quot;],
  t1 = outfiles[&quot;T1&quot;],
  t2 = outfiles[&quot;T2&quot;],
  pd = outfiles[&quot;PD&quot;],
  preproc = FALSE,
  brain_mask = outfiles[&quot;brain_mask&quot;],
  eroder = &quot;oasis&quot;)</code></pre>
<pre><code>Checking File inputs</code></pre>
<pre><code>Eroding Brain Mask</code></pre>
<pre><code>Normalizing Images using Z-score</code></pre>
<pre><code>Voxel Selection Procedure</code></pre>
<pre><code>Smoothing Images: Sigma = 10</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b40ea93a.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5e8820ea.nii.gz&quot;  -s 10 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b3b291322&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5e8820ea.nii.gz&quot; -s 10 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5e8820ea_10&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b3b291322&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5e8820ea_10&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5e8820ea.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b3b291322&quot;;</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5a73b86.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b2634dd50.nii.gz&quot;  -s 10 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b58adc2c8&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b2634dd50.nii.gz&quot; -s 10 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b2634dd50_10&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b58adc2c8&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b2634dd50_10&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b2634dd50.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b58adc2c8&quot;;</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b77cf05f3.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b388fd1f8.nii.gz&quot;  -s 10 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b6a220dca&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b388fd1f8.nii.gz&quot; -s 10 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b388fd1f8_10&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b6a220dca&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b388fd1f8_10&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b388fd1f8.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b6a220dca&quot;;</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b61b77f35.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5600a2b1.nii.gz&quot;  -s 10 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b43b93e93&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5600a2b1.nii.gz&quot; -s 10 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5600a2b1_10&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b43b93e93&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5600a2b1_10&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b5600a2b1.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b43b93e93&quot;;</code></pre>
<pre><code>Smoothing Images: Sigma = 20</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b36bb47a1.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b415bb719.nii.gz&quot;  -s 20 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b6c51ebd4&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b415bb719.nii.gz&quot; -s 20 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b415bb719_20&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b6c51ebd4&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b415bb719_20&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b415bb719.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b6c51ebd4&quot;;</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b7651e2da.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b7a0492e5.nii.gz&quot;  -s 20 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b424836f8&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b7a0492e5.nii.gz&quot; -s 20 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b7a0492e5_20&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b424836f8&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b7a0492e5_20&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b7a0492e5.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b424836f8&quot;;</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b1310f5c7.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b3e77e598.nii.gz&quot;  -s 20 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b31827e32&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b3e77e598.nii.gz&quot; -s 20 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b3e77e598_20&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b31827e32&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b3e77e598_20&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b3e77e598.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b31827e32&quot;;</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b6e2b1e02.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b50bf4dcf.nii.gz&quot;  -s 20 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b3f8d7a73&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b50bf4dcf.nii.gz&quot; -s 20 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b50bf4dcf_20&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b3f8d7a73&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b50bf4dcf_20&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b50bf4dcf.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b3f8d7a73&quot;;</code></pre>
<pre class="r"><code>oasis_dataframe = df_list$oasis_dataframe
brain_mask = df_list$brain_mask
top_voxels = df_list$voxel_selection</code></pre>
<p>We will use the model included in the <code>oasis</code> package since we do not currently have a gold standard. After predicting, we smooth the probability map using adjacent voxel probabilities. We then threshold this probability map to give a binary prediction of lesions.</p>
<pre class="r"><code>## make the model predictions
predictions = predict( oasis::oasis_model,
                        newdata = oasis_dataframe,
                        type = &#39;response&#39;)
pred_img = niftiarr(brain_mask, 0)
pred_img[top_voxels == 1] = predictions
library(fslr)</code></pre>
<pre><code>
Attaching package: &#39;fslr&#39;</code></pre>
<pre><code>The following object is masked from &#39;package:git2r&#39;:

    checkout</code></pre>
<pre class="r"><code>##smooth the probability map
prob_map = fslsmooth(pred_img, sigma = 1.25,
                      mask = brain_mask, retimg = TRUE,
                      smooth_mask = TRUE)</code></pre>
<pre><code>fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b766c615d.nii.gz&quot;  -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b456c5d68.nii.gz&quot;  -s 1.25 &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b4d687a73&quot;; fslmaths &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b456c5d68.nii.gz&quot; -s 1.25 &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b456c5d68_1.25&quot;; fslmaths &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b4d687a73&quot; -div &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b456c5d68_1.25&quot; -mas &quot;/private/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T/RtmpZT2MJa/file9f8b456c5d68.nii.gz&quot; &quot;/var/folders/1s/wrtqcpxn685_zk570bnx9_rr0000gr/T//RtmpZT2MJa/file9f8b4d687a73&quot;;</code></pre>
<pre class="r"><code>threshold = 0.16
binary_map = prob_map &gt; threshold</code></pre>
<p>We can apply our empty-slice reduction from earlier so that the binary prediction and the normalized images are the same dimensions.</p>
<p>We will overlay the predictions on the images and use the <code>alpha</code> function from the <code>scales</code> package to alpha-blend the intensities so we can see the underlying image as well as the areas delineated as lesion.</p>
<pre class="r"><code>library(scales)

reduced_binary_map = apply_empty_dim(img = binary_map,
                                     inds = dd$inds)
ortho2(norm_imgs$FLAIR, reduced_binary_map,
       col.y = scales::alpha(&quot;red&quot;, 0.5))</code></pre>
<p><img src="index_files/figure-html/pred_plot-1.png" /><!-- --></p>
<pre class="r"><code>double_ortho(norm_imgs$FLAIR, reduced_binary_map, col.y = &quot;red&quot;)</code></pre>
<p><img src="index_files/figure-html/pred_plot-2.png" /><!-- --></p>
<pre class="r"><code>multi_overlay(
  norm_imgs, 
  y = list(reduced_binary_map,
           reduced_binary_map,
           reduced_binary_map,
           reduced_binary_map),
  col.y = scales::alpha(&quot;red&quot;, 0.5) ,
  z = z, 
  text = names(norm_imgs),
  text.x = 
    rep(0.5, length(norm_imgs)),
  text.y = 
    rep(1.4, length(norm_imgs)), 
  text.cex = 
    rep(2.5, length(norm_imgs)))</code></pre>
<p><img src="index_files/figure-html/pred_plot-3.png" /><!-- --></p>
</div>
<div id="analagous-preprocessing-with-antsr-and-extrantsr" class="section level2">
<h2>Analagous preprocessing with ANTsR and extrantsr</h2>
<p>Although the original OASIS model was done using FSL, we can perform preprocessing in ANTsR if we later would like to train a model based on this preprocessing. Note, the original model may not work well as it may be specific to the preprocessing done in FSL.</p>
<pre class="r"><code>check = check_package_version(&quot;extrantsr&quot;, min_version = &quot;2.2.1&quot;)
if (!check) {
  devtools::install_github(&quot;muschellij2/extrantsr&quot;)
}</code></pre>
<pre class="r"><code>dat = ss[[1]]
print(dat)</code></pre>
<pre><code>                          FLAIR                              PD 
&quot;data/01-Baseline_FLAIR.nii.gz&quot;    &quot;data/01-Baseline_PD.nii.gz&quot; 
                             T1                              T2 
   &quot;data/01-Baseline_T1.nii.gz&quot;    &quot;data/01-Baseline_T2.nii.gz&quot; </code></pre>
<pre class="r"><code># preparing output filenames
ants_outfiles = nii.stub(dat)
n4_brain_mask = gsub(&quot;_T1$&quot;, &quot;&quot;, ants_outfiles[&quot;T1&quot;])
n4_brain_mask = paste0(n4_brain_mask, &quot;_N4_Brain_Mask.nii.gz&quot;)
ants_outfiles = paste0(ants_outfiles, &quot;_ants_preprocessed.nii.gz&quot;)
names(ants_outfiles) = names(dat)
ants_outfiles = ants_outfiles[ names(ants_outfiles) != &quot;mask&quot;]

if (!all(file.exists(ants_outfiles))) {
  pre = preprocess_mri_within(
    files = dat[c(&quot;T1&quot;, &quot;T2&quot;, &quot;FLAIR&quot;, &quot;PD&quot;)],
    outfiles = ants_outfiles[c(&quot;T1&quot;, &quot;T2&quot;, &quot;FLAIR&quot;, &quot;PD&quot;)],
    correct = TRUE,
    correction = &quot;N4&quot;,
    skull_strip = FALSE,
    typeofTransform = &quot;Rigid&quot;,
    interpolator = &quot;LanczosWindowedSinc&quot;)
  
  ss = fslbet_robust(
    ants_outfiles[&quot;T1&quot;], 
    correct = FALSE,
    bet.opts = &quot;-v&quot;)
  ss = ss &gt; 0
  writenii(ss, filename = n4_brain_mask)
  
  imgs = lapply(ants_outfiles[c(&quot;T1&quot;, &quot;T2&quot;, &quot;FLAIR&quot;, &quot;PD&quot;)],
                readnii)
  imgs = lapply(imgs, mask_img, ss)
  
  imgs = lapply(imgs, bias_correct, correction = &quot;N4&quot;,
                mask = ss)
  mapply(function(img, fname){
    writenii(img, filename = fname)
  }, imgs, ants_outfiles[c(&quot;T1&quot;, &quot;T2&quot;, &quot;FLAIR&quot;, &quot;PD&quot;)])
  
}</code></pre>
<pre class="r"><code>L = oasis_train_dataframe(
  flair = ants_outfiles[&quot;FLAIR&quot;],
  t1 = ants_outfiles[&quot;T1&quot;],
  t2 = ants_outfiles[&quot;T2&quot;],
  pd = ants_outfiles[&quot;PD&quot;],
  preproc = FALSE,
  brain_mask = n4_brain_mask,
  eroder = &quot;oasis&quot;)

ants_oasis_dataframe = L$oasis_dataframe
ants_brain_mask = L$brain_mask
ants_top_voxels = L$voxel_selection</code></pre>
<pre class="r"><code>library(cluster)
km = kmeans(x = ants_oasis_dataframe, centers = 4)
km_img = niftiarr(ants_brain_mask, 0)
km_img[ants_top_voxels == 1] = km$cluster
n4_flair = readnii(ants_outfiles[&quot;FLAIR&quot;])
res = clara(x = ants_oasis_dataframe, k = 4)
cl_img = niftiarr(ants_brain_mask, 0)
cl_img[ants_top_voxels == 1] = res$clustering
ortho2(n4_flair, cl_img &gt; 3, col.y = scales::alpha(&quot;red&quot;, 0.5))</code></pre>
<div id="refs" class="references">
<div id="ref-muschelli2015fslr">
<p>Muschelli, John, Elizabeth Sweeney, Martin Lindquist, and Ciprian Crainiceanu. 2015. “Fslr: Connecting the Fsl Software with R.” <em>The R Journal</em> 7 (1): 163–75.</p>
</div>
<div id="ref-sweeney2013oasis">
<p>Sweeney, Elizabeth M, Russell T Shinohara, Navid Shiee, Farrah J Mateen, Avni A Chudgar, Jennifer L Cuzzocreo, Peter A Calabresi, Dzung L Pham, Daniel S Reich, and Ciprian M Crainiceanu. 2013. “OASIS Is Automated Statistical Inference for Segmentation, with Applications to Multiple Sclerosis Lesion Segmentation in Mri.” <em>NeuroImage: Clinical</em> 2. Elsevier: 402–13.</p>
</div>
<div id="ref-sweeney2013automatic">
<p>Sweeney, EM, RT Shinohara, CD Shea, DS Reich, and CM Crainiceanu. 2013. “Automatic Lesion Incidence Estimation and Detection in Multiple Sclerosis Using Multisequence Longitudinal Mri.” <em>American Journal of Neuroradiology</em> 34 (1). Am Soc Neuroradiology: 68–73.</p>
</div>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
